<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>中央处理器</title>
      <link href="/2021/11/14/zhong-yang-chu-li-qi/"/>
      <url>/2021/11/14/zhong-yang-chu-li-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><strong>程序控制：</strong>控制程序中指令执行的顺序。</li><li><strong>操作控制：</strong>产生指令执行所需的操作控制信号，以控制执行部件运行。</li><li><strong>时序控制：</strong>控制每个操作控制信号的开始和持续时间。</li><li><strong>数据加工：</strong>对数据进行运算，在相关部件间传送。</li><li><strong>中断处理：</strong>及时响应内部异常和外部中断请求。</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><blockquote><p>CPU主要由<strong>运算器</strong>和<strong>控制器</strong>组成。现代CPU增加了其他单元。</p><p>下图为CPU的基本组成。</p></blockquote><p><img src="/2021/11/14/zhong-yang-chu-li-qi/image-20211114192454072.png" alt=""></p><p>CPU主要寄存器</p><ul><li><strong>程序计数器(PC)</strong>：保存将要执行的指令字节地址。</li><li><strong>地址寄存器(AR)</strong>：保存CPU访问主存的单元地址。非必需。</li><li><strong>数据寄存器(DR)</strong>：存放主存中读取的数据或准备写入主存的数据。非必需。</li><li><strong>指令寄存器(IR)</strong>：保存当前正在执行的指令。</li><li><strong>通用寄存器组(GR)</strong>：这些寄存器的功能有多种用途。在x86中为<code>EAX,EBX···</code>等。</li><li><strong>程序状态字寄存器(PSW/PSR)</strong>：保存算术运算、逻辑运算、测试等指令设立的各种条件标志。还可用于保存中断和系统工作的状态信息。非必需。</li></ul><p>操作控制器</p><blockquote></blockquote><p>时序产生器</p><blockquote></blockquote><hr><h3 id="2-指令周期"><a href="#2-指令周期" class="headerlink" title="2.指令周期"></a>2.指令周期</h3><h4 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h4><blockquote><p>由控制器根据程序对应的机器指令序列逐条执行指令。</p></blockquote><p><img src="/2021/11/14/zhong-yang-chu-li-qi/image-20211114200429096.png" style="zoom:50%;"></p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><blockquote><p>一条指令从取出到完成所需要的时间。</p></blockquote><p><strong>不同阶段</strong></p><ul><li><strong>取指周期</strong>：CPU以PC的内容为地址从主存中取出指令，并计算后续指令的地址。</li><li><strong>译码周期/取操作数周期</strong>：对指令寄存器的指令字进行指令译码。</li><li><strong>执行周期</strong>：对已取出操作数进行加工处理。</li><li><strong>写回周期</strong>：将运算结果写回到寄存器或存储器。</li></ul><hr><h3 id="3-数据通路"><a href="#3-数据通路" class="headerlink" title="3.数据通路"></a>3.数据通路</h3><blockquote><p>根据性质分成：</p><p><strong>数据处理单元：</strong>由组合逻辑电路构成，输出只与当前输入有关，负责对数据进行加工处理。</p><p><strong>状态存储单元：</strong>带有存储功能的单元，如存储器和寄存器。包含输入端、写使能控制端、时钟输入端和输出端。</p></blockquote><p>数据通路模型：</p><p><img src="/2021/11/14/zhong-yang-chu-li-qi/image-20211117105132482.png" style="zoom:50%;"></p><h4 id="单总线数据通路"><a href="#单总线数据通路" class="headerlink" title="单总线数据通路"></a>单总线数据通路</h4><blockquote><p>CPU中的运算器、控制器、寄存器堆等核心部件均通过一条内部的公共总线连接。</p><p>同一时刻只有一个部件向总线输出数据。</p><p>数据传输只能分时使用总线。</p></blockquote><hr><h4 id="专用通路结构数据通路"><a href="#专用通路结构数据通路" class="headerlink" title="专用通路结构数据通路"></a>专用通路结构数据通路</h4><blockquote><p>各功能部件之间均基于专用的数据传输通路连接。</p><p>各通路中的数据可并行传输，控制较总线结构要简单。</p></blockquote><hr><h3 id="4-时序与控制"><a href="#4-时序与控制" class="headerlink" title="4.时序与控制"></a>4.时序与控制</h3><p><strong>中央处理器的时序</strong></p><blockquote><p>传统三级时序：状态周期、节拍点位、节拍脉冲。</p></blockquote><p><img src="/2021/11/14/zhong-yang-chu-li-qi/image-20211118094906449.png" alt=""></p><ul><li>节拍电位变化的时刻决定了控制信号产生的时刻</li><li>节拍电位的长度决定控制信号的持续时间</li><li>脉冲跳变时刻决定寄存器，存储器锁存时刻</li><li>为满足寄存器的定时机制，正确写入数据，节拍电位变化时刻应该和脉冲跳变时刻错开</li></ul><blockquote><p>现代时序︰只有时钟周期，指令执行过程是时钟驱动的状态机。 </p></blockquote><hr><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><blockquote><p><strong>同步控制方式</strong>：选取部件中最长操作时间作为统一的时间间隔进行时序同步。</p><p><strong>异步控制方式</strong>：系统不设立统一的时间间隔标准，各部件设置各自的时序系统，分别实现各自的时序控制，主要采用异步应答通信机制实现。</p><p><strong>联合控制方式</strong>：将同步控制与异步控制相结合，对大多数需要节拍数相近的指令，采用同步控制；而对少数需要节拍数多的指令或节拍数不固定的指令，采用异步控制。 </p></blockquote><hr><h4 id="时序发生器"><a href="#时序发生器" class="headerlink" title="时序发生器"></a>时序发生器</h4><blockquote><p>功能：输入时钟脉冲信号，指令译码信号、反馈信号持续不断的产生状态周期电位和节拍电位，操作控制器利用这些周期、节拍电位信号对操作控制信号进行时序的调制，生成控制信号序列。 </p></blockquote><hr><h3 id="5-硬布线控制器"><a href="#5-硬布线控制器" class="headerlink" title="5.硬布线控制器"></a>5.硬布线控制器</h3><blockquote><p>直接由各种类型的逻辑门电路和触发器构成，内部结构复杂但速度较快。</p></blockquote><h4 id="三级时序硬布线控制器"><a href="#三级时序硬布线控制器" class="headerlink" title="三级时序硬布线控制器"></a>三级时序硬布线控制器</h4><h4 id="现代时序硬布线控制器"><a href="#现代时序硬布线控制器" class="headerlink" title="现代时序硬布线控制器"></a>现代时序硬布线控制器</h4><hr><h3 id="6-微程序控制器"><a href="#6-微程序控制器" class="headerlink" title="6.微程序控制器"></a>6.微程序控制器</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类文件结构</title>
      <link href="/2021/11/06/java-lei-wen-jian-jie-gou/"/>
      <url>/2021/11/06/java-lei-wen-jian-jie-gou/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指令系统</title>
      <link href="/2021/11/04/zhi-ling-xi-tong/"/>
      <url>/2021/11/04/zhi-ling-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="1-指令格式"><a href="#1-指令格式" class="headerlink" title="1.指令格式"></a>1.指令格式</h3><blockquote><p>指令格式是用二进制代码表示指令的结构形式。</p><p>要明确指令处理的<strong>操作数</strong>、对操作数的<strong>操作</strong>、获取操作数的<strong>方式</strong>等。</p></blockquote><p><img src="/2021/11/04/zhi-ling-xi-tong/image-20211104091223370.png" style="zoom:50%;"></p><ul><li>上图所示操作码字段解决进行何种操作</li><li>地址码字段解决处理什么操作数的问题，可以包含多个操作数</li><li>寻址方式字段解决如何获取操作数，可以包含在地址码中，也可以因此在操作码中</li></ul><p><strong>指令字长度</strong></p><blockquote><p>一条指令中所包含的二进制位数。又称<strong>指令字长</strong>。</p><p><strong>定长指令系统：</strong>指令长度固定，结构简单，有利于CPU取指令、译码和指令顺序访址，方便硬件实现。但存在平均指令长度较长、冗余状态较多、不容易扩展问题。</p><p><strong>变长指令系统：</strong>指令长度可变，结构灵活，冗余状态较少，平均指令长度较短，可扩展性好。但取指令和译码不便，增加硬件设计难度。</p></blockquote><ul><li>根据指令和机器字长的关系，分为：半字长、单字长、多字长指令。</li></ul><p><strong>指令地址码</strong></p><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/2021/10/31/java-lei-jia-zai-ji-zhi/"/>
      <url>/2021/10/31/java-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<strong>类加载机制</strong>。 </p><p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p></blockquote><h3 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1.类加载时机"></a>1.类加载时机</h3><blockquote><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。</p><p>其中验证、准备、解析三个部分统称为连接（Linking）。</p></blockquote><p><img src="/2021/10/31/java-lei-jia-zai-ji-zhi/image-20211106154126066.png" alt=""></p><ul><li><p>对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。<ul><li>使用<code>new</code>关键字实例化对象的时候</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li><li>调用一个类型的静态方法的时候</li></ul></li><li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含<code>main()</code>方法的那个类），虚拟机会先初始化这个主类</li><li>当一个接口中定义了JDK 8新加入的默认方法（被<code>default</code>关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li></ul></li><li><p>引用类型的方式都不会触发初始化，称为<strong>被动引用</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 被动使用类字段演示一： * 通过子类引用父类的静态字段，不会导致子类初始化**/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 非主动使用类字段演示**/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化</li></ul><hr><h3 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2.类加载过程"></a>2.类加载过程</h3><h4 id="2-1加载"><a href="#2-1加载" class="headerlink" title="2.1加载"></a>2.1加载</h4><blockquote><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li></ul></blockquote><h4 id="2-2验证"><a href="#2-2验证" class="headerlink" title="2.2验证"></a>2.2验证</h4><blockquote><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p></blockquote><h4 id="2-3准备"><a href="#2-3准备" class="headerlink" title="2.3准备"></a>2.3准备</h4><blockquote><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。</p></blockquote><ul><li>关于准备阶段，还有两个容易产生混淆的概念<ul><li>首先是这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li><li>其次是这里所说的初始值“通常情况”下是数据类型的零值。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟存储器</title>
      <link href="/2021/10/28/xu-ni-cun-chu-qi/"/>
      <url>/2021/10/28/xu-ni-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="1-物理和虚拟寻址"><a href="#1-物理和虚拟寻址" class="headerlink" title="1.物理和虚拟寻址"></a>1.物理和虚拟寻址</h3><blockquote><p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址</strong>。</p><p>CPU访问内存的最自然的方式就是使用物理地址。这种方式称为<strong>物理寻址</strong>。</p></blockquote><p><img src="/2021/10/28/xu-ni-cun-chu-qi/image-20211028094010419.png" style="zoom:50%;"></p><ul><li><p>提供给程序员的内存模型仅仅是物理内存，一组从0到某个最大值的地址，每个地址通常对应一个字节单元。</p></li><li><p>在这种情况下，内存中不可能同时有两个正在运行的程序。如果第一个程序写了一个新值到比如<code>addr 2000</code>，这将擦除第二个程序存储在那里的值。</p></li></ul><p>示例：</p><blockquote><p>有两个程序，每个程序的大小为16 KB。前者为阴影区域。</p></blockquote><ul><li>第一个程序从<code>addr 24</code>开始，<code>addr 24</code>包含一个<code>MOV</code>指令。</li><li>第二个程序从<code>addr 28</code>开始，<code>addr 28</code>包含一个<code>CMP</code>指令。</li><li>当两个程序从地址0开始在内存中连续加载时，有图(c)的情况。</li><li>在第一个程序运行后，操作系统可能决定运行第二个程序，该程序已加载在第一个程序之上，<code>addr 16384</code>。执行的第一个指令是<code>jmp 28</code>，它跳转到在第一个程序中的<code>ADD</code>指令，而不是它应该跳转到的<code>CMP</code>指令。</li></ul><blockquote><p>核心问题是这两个程序都引用<strong>绝对物理内存</strong>。 </p></blockquote><p><img src="/2021/10/28/xu-ni-cun-chu-qi/image-20211028095123548.png" style="zoom:50%;"></p><hr><blockquote><p>现代处理器一般使用<strong>虚拟寻址</strong>。</p><p>CPU通过生成一个<strong>虛拟地址</strong>(Virtual Address，VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的<strong>物理地址</strong>。</p><p>将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>(address translation)。</p><p>CPU芯片上叫做<strong>内存管理单元</strong>(Memory Management Unit, MMU)的专用硬件，利用存放在主存中的<strong>查询表</strong>来动态翻译虚拟地址，该表的内容由操作系统管理。</p></blockquote><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h3><blockquote><p>虚拟存储器通过在主存和辅存之间增加部分软件和硬件，使主存和辅存构成整体，如同大容量主存一样。</p><p>利用虚拟存储器提供的虚拟地址进行编程，在主存空间不增加的情况下不受主存空间的限制。</p></blockquote><ul><li>虚拟存储器充分利用程序局部性，采用按需加载方式。<ul><li>不直接将程序和代码载入主存，仅在相应的<strong>虚拟地址转换表</strong>登记虚拟地址对应<strong>磁盘地址</strong>。</li><li>程序执行并访问对应虚拟地址时，产生<strong>缺页异常</strong>，由操作系统从磁盘调入数据块。</li><li>程序仅加载一小部分空间即可运行，提高主存利用率。</li></ul></li></ul><p><strong>地址空间</strong></p><blockquote><p>虚拟存储器有三种地址空间：</p><p>虚拟地址空间：程序员用来编写程序的空间，虚地址</p><p>主存地址空间：物理地址空间，或叫实地址空间，实地址</p><p>辅存地址空间：磁盘的地址空间，辅存地址</p></blockquote><hr><h3 id="3-页式虚拟存储器"><a href="#3-页式虚拟存储器" class="headerlink" title="3.页式虚拟存储器"></a>3.页式虚拟存储器</h3><blockquote><p>以页（Page）为逻辑划分信息传送单位。</p></blockquote><p><strong>虚拟地址划分</strong></p><blockquote><p>虚拟地址被划分为<strong>虚拟页号</strong>（Virtual Page Number，VPN）和<strong>虚拟页偏移</strong>（Virtual Page Offset，VPO），物理地址也被划分为<strong>物理页号</strong>和<strong>物理页偏移</strong>。</p></blockquote><p><strong>页表</strong></p><blockquote><p>页表是一张保存虚拟页号VPN和物理页号PPN对应关系的查找表。</p><p>VPN作为索引进行访问，每个表项包括有效位、物理页号、修改位等。</p></blockquote><p><img src="/2021/10/28/xu-ni-cun-chu-qi/image-20211028103256423.png" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
            <tag> 虚拟存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IP层</title>
      <link href="/2021/10/27/wang-luo-ip-ceng/"/>
      <url>/2021/10/27/wang-luo-ip-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="网络IP层"><a href="#网络IP层" class="headerlink" title="网络IP层"></a>网络IP层</h2><h3 id="1-数据层面"><a href="#1-数据层面" class="headerlink" title="1.数据层面"></a>1.数据层面</h3><h4 id="1-1-网络层概述"><a href="#1-1-网络层概述" class="headerlink" title="1.1 网络层概述"></a>1.1 网络层概述</h4><blockquote><p>网络层的作用从表面上看极为简单，即将分组从一台发送主机移动到一台接收主机。为此，需要使用两种重要的网络层功能: </p></blockquote><ul><li><strong>转发</strong>。当一个分组到达某路由器的一条输人链路时，该路由器必须将该分组移动到适当的输出链路。转发是在<strong>数据平面</strong>中实现的<strong>唯一功能</strong>。</li><li><strong>路由选择</strong>。当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法(routing algorithm)。<strong>路由选择</strong>在网络层的<strong>控制平面</strong>中实现。</li></ul><blockquote><p>更为精确的描述：</p><p><strong>转发</strong>是指将分组从一个输入链路接口转移到适当的输出链路接口的<strong>路由器本地</strong>操作。时间尺度短：ns级别</p><p><strong>路由选择</strong>是指确定分组从源目的地所采取的端到端路径的网络范围处理过程。时间尺度长：s级别</p></blockquote><ul><li>每台网络路由器中有一个关键元素是它的<strong>转发表(forwardingtable)</strong>。路由器检查到达分组首部字段值，使用这些值在其转发表中搜索，转发分组。</li><li>这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的<strong>输出链路接口</strong>。</li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027141029742.png" style="zoom: 40%;"></p><p><strong>控制平面</strong></p><blockquote><p>路由选择算法决定了插入该转发表的内容。路由选择算法运行在每台路由器中，并且每台路由器都有转发和路由选择两种功能。</p></blockquote><p><strong>网络服务模型</strong></p><blockquote><p>网络服务模型定义了分组在发送和接收端系统之间的端到端运输特性。</p></blockquote><ul><li><strong>确保交付：</strong>确保分组最终到达目的地</li><li><strong>具有时延上界的确保交付：</strong>在特定的主机到主机时延上界内（100ms内 e.g.）交付</li><li><strong>有序分组交付</strong>：确保分组以发送顺序到达目的地</li><li><strong>确保最小带宽：</strong>在双方之间模拟一条特定比特速率的传输链路，只要发送方传输速率低于该速率，所有分组确保交付到目的主机</li><li><strong>安全性：</strong>在发送方加密数据报，在接收方解密数据报。</li></ul><p>因特网的网络层提供了单一的服务，称为<strong>尽力而为服务</strong>( best- effort service)。使用尽力而为服务，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付;既不能保证端到端时延，也不能保证有最小的带宽。</p><hr><h4 id="1-2-路由器工作原理"><a href="#1-2-路由器工作原理" class="headerlink" title="1.2 路由器工作原理"></a>1.2 路由器工作原理</h4><blockquote><p>下图显示了路由器的总体视图。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027142710900.png" style="zoom:40%;"></p><ul><li><strong>输入端口</strong><ul><li>执行物理层功能，在路由器上终止传入的物理链路。</li><li>与位于输入链路远端的数据链路层交互来执行数据链路层功能。</li><li>在输入端口执行查找功能，通过转发表决定路由器的输出端口。</li></ul></li><li><strong>交换结构</strong><ul><li>交换结构将路由器的输入端口连接到它的输出端口。这种交换结构完全<br>包含在路由器之中，即是一个网络路由器中的网络。</li></ul></li><li><strong>输出端口</strong><ul><li>输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。</li><li>当一条链路是双向的时(即承载两个方向的流量)，输出端口通常与该链路的输入端口成对出现在同一线路卡上。</li></ul></li><li><strong>路由选择处理器</strong>：<ul><li>路由选择处理器执行控制平面功能。</li><li>在传统的路由器中，它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。</li><li>在SDN路由器中，路由选择处理器负责与远程控制器通信，接收由远程控制器计算的转发表项并安装在输入端口。</li></ul></li></ul><hr><p><strong>输入端口处理和基于目的地转发</strong></p><blockquote><p>路由器用分组目的地址的前缀(prefix)与该表中的表项进行匹配;如果存在一个匹配项，则路由器向与该匹配项相关联的链路转发分组。</p><p>当有多个匹配时，路由器使用最长前缀匹配规则，即在表中寻找最长的匹配项。</p></blockquote><ul><li>通过查找确定了某分组的输出端口，则该分组就能够发送进人交换结构。</li><li>如果来自其他输入端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时被暂时阻塞。因此，一个被阻塞的分组必须要在输人端口处排队，并等待稍后被及时调度以通过交换结构。</li></ul><p>输入端口还需完成其他动作：</p><ol><li>必须出现物理层和链路层处理</li><li>必须检查分组的版本号、检验和以及寿命字段，并且重写后两个字段;</li><li>必须更新用于网络管理的计数器(如接收到的IP数据报的数目)。</li></ol><hr><p><strong>交换</strong></p><blockquote><p>交换结构位于一台路由器的核心部位，通过交换结构，分组能实际地从一个输入端口交换( 即转发)到一个输出端口中。交换可以用许多方式完成。</p></blockquote><ul><li><strong>经内存交换</strong>。在输入端口与输出端口之间的交换是在CPU (路由选择处理器)的直接控制下完成的。输入与输出端口的功能就像在传统操作系统中的I/O设备一样。<ul><li>分组到达输入端口时，通过中断被路由选择器复制进（<strong>读</strong>）内存。</li><li>从首部提取目的地址，在转发表中找出输出端口，将该分组复制到（<strong>写</strong>）输出端口的缓存。</li><li>如果内存带宽为每秒读写B个分组，则总的转发吞吐量(分组从输入端口被传送到输出端口的总速率，即一次<strong>读</strong>和一次<strong>写</strong>)必然小于B/2。</li></ul></li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027145001684.png" style="zoom:40%;"></p><ul><li><p><strong>经总线交换</strong>。输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。</p><ul><li>输入端口为分组预先计划一个标签，指示输出端口，分组传送到所有输出端口，但只有与<strong>该标签匹配的端口</strong>才能保存该分组。</li><li>然后标签在输出端口被去除，因为其仅用于交换机内部来跨越总线。</li><li>如果多个不同输出端口分组同时到达路由器，一次只有一个分组能够跨越总线。</li><li>每个分组必须跨过单一总线，故路由器的交换带宽受总线速率的限制。</li></ul></li><li><p><strong>经互联网络交换</strong>。一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直的总线与每条水平的总线交叉，交叉点通过交换结构控制器能开启和闭合。</p><ul><li>分组到达端口A，需要转发到端口Y时，交换机控制器闭合总线A和Y交叉部位的交叉点。</li><li>来自端口B的一个分组在同一时间能够转发到端口X，因为A到Y和B到X的分组使用不同的输入和输出总线。</li><li>纵横式交换机是非阻塞的(non-blocking)，即只要没有其他分组当前被转发到该输出端口，分组将不会被其他分组阻塞。如果目的地为相同的输出端口，则一个分组必须在输入端等待。</li></ul></li></ul><hr><p><strong>输出端口处理</strong></p><blockquote><p>输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027150908497.png" style="zoom:50%;"></p><hr><p><strong>排队</strong></p><blockquote><p>排队的位置和程度(在输入端口或者在输出端口排队)将取决于流量负载、交换结构的相对速率和线路速率。因为随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现<strong>丢包</strong>(packet loss)。</p></blockquote><p><strong>1.输入排队</strong><br>如果交换结构不能快得使所有到达分组无时延地通过它传送，在输入端口将出现分组排队，到达的分组必须加入输入端口队列中，以等待通过交换结构传送到输出端口。</p><p>假定该交换结构决定发送左上角队列前端的分组。在这种情况下，左下角队列中的深色阴影分组必须等待。但不仅该分组要等待，左下角队列中排在该分组后面的浅色阴影分组也要等待，即使右中侧输出端口(浅色阴影分组的目的地)中无竞争。</p><p>这种现象叫作输入排队交换机中的<strong>线路前部(Head-Of-the-Line HOL)阻塞</strong></p><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027151943793.png" style="zoom:50%;"></p><p><strong>2.输出排队</strong></p><ul><li>在时刻t，每个输入端口都到达了一个分组，每个分组都是发往最上侧的输出端口。</li><li>假定线路速度相同，交换机以3倍于线路速度的速度运行，一个时间单位以后，所有三个初始分组都被传送到输出端口,并排队等待传输。</li><li>在下一个时间单位中，这三个分组中的一个将通过输出链路发送出去。</li><li>之后又有两个新分组已到达交换机的入端；这些分组之一要发往最上侧的输出端口。</li><li>输出端口的<strong>分组调度</strong>( packet scheduler) 在这些排队分组中选择一个分组来传输</li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153011499.png" style="zoom:40%;"></p><hr><p><strong>分组调度</strong></p><p><strong>1.先进先出(FIFO)</strong></p><blockquote><p>FIFO(也称为先来先服务)调度规则按照分组到达输出链路队列的相同次序来选择分组在链路上传输。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153557356.png" style="zoom:50%;"></p><p><strong>2.优先权排队</strong></p><blockquote><p>到达输出链路的分组被分类放入输出队列中的<strong>优先权类</strong>，如图所示。</p><p>在同一优先权类的分组之间通常以FIFO方式完成。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153617049.png" style="zoom:50%;"></p><p><strong>3.循环和加权公平排队</strong></p><blockquote><p>在循环排队规则(round robin queuing discipline) 下，分组像使用优先权排队那样被分类。然而，在类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。</p><p>一个所谓的保持工作排队(work-conserving queuing)规则在有分组排队等待传输时，不允许链路保持空闲。当类中没有分组时，将立即检查循环序列中的下一个类。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153859087.png" style="zoom:50%;"></p><hr><h4 id="1-3-网际协议-IPV4、寻址、IPV6"><a href="#1-3-网际协议-IPV4、寻址、IPV6" class="headerlink" title="1.3 网际协议 IPV4、寻址、IPV6"></a>1.3 网际协议 IPV4、寻址、IPV6</h4><p><strong>IPV4数据报格式</strong></p><blockquote><p>网络层分组被称为<strong>数据报</strong>。</p><p>一个IP数据报有20 byte的首部（不包含选项），若数据报承载了一个TCP报文段（20 byte首部），则每个数据报共有40 byte的首部。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027154105483.png" style="zoom: 50%;"></p><hr><p><strong>IPV4数据报分片</strong></p><blockquote><p>不是所有链路层协议都能承载相同长度的网络层分组。以太网帧能够承载不超过1500字节的数据，而某些广域网链路的帧可承载不超过576字节的数据。</p><p>一个链路层帧能承载的最大数据量叫作<strong>最大传送单元</strong>(Maximum Transmission Unit, <strong>MTU</strong>) </p><p>因为每个IP数据报封装在链路层帧在路由器间传输，故链路层协议的MTU严格地限制着IP数据报的长度。</p></blockquote><ul><li><p><strong>片</strong>在其到达目的地运输层以前需要重新组装。为坚持网络内核保持简单的原则，IPv4的设计者决定将数据报的重新组装工作放到端系统中，而不是放到网络路由器中。</p></li><li><p>为了让目的主机执行这些重新组装任务，IPv4的设计者将<strong>标识</strong>、<strong>标志</strong>和<strong>片偏移</strong>字段放在IP数据报首部中。</p><ul><li>当生成一个数据报时，发送主机在为该数据报贴上<strong>标识号</strong>。发送主机通常将它发送的每个数据报的标识号+1。</li><li>当某路由器需要对一个数据报分片时，形成的每个数据报具有<strong>初始数据报标识号</strong>。</li><li>当从同一发送主机收到一系列数据报时，检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。</li><li>为了让目的主机绝对地相信它已收到了初始数据报的最后一个片，最后一个片的<strong>标志</strong>比特被设为<strong>0</strong>，而所有其他片的<strong>标志</strong>比特被设为<strong>1</strong>。</li><li><strong>片偏移字段</strong>指定该片在初始IP数据报的位置。</li></ul></li></ul><hr><p><strong>IPV4编址</strong></p><blockquote><p>主机与物理链路之间的边界叫做<strong>接口</strong>。IP要求每台主机和路由器<strong>接口</strong>拥有自己的<strong>IP地址</strong>以发送和接收IP数据报。因此，从技术上讲，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p><p>为便于书写，IPV4地址采用点分十进制记法，如<code>127.0.0.1</code>。</p><p><code>223.1.1.0/24</code> 其中 <code>/24</code> 称为<strong>子网掩码</strong>，表示最左侧24位定义了子网地址。</p><p><strong>子网</strong>：分开主机和路由器的接口，使用接口端接入这些隔离网络的端点，每个隔离网络都叫做子网。</p></blockquote><p>因特网地址分配策略：<strong>无类别域间路由选择（Classless Interdomain Routing CIDR）</strong>。</p><ul><li>使用子网寻址，IP地址分为两部分，<code>a.b.c.d/x</code>，<code>x</code> 指示了地址的第一部分bits，一般称为地址的<strong>前缀</strong>。</li><li>一个组织通常被分配一块连续的地址，即有相同前缀。</li></ul><blockquote><p><strong>广播地址</strong>：<code>255.255.255.255</code>。目的地为该地址的报文段会被转发给同一网络所有主机。</p></blockquote><hr><p><strong>DHCP</strong></p><blockquote><p>动态主机配置协议（Dynamic Host Configuration)，允许主机自动获取一个IP地址。同时获得子网掩码、第一跳路由器地址（默认网关）、本地DNS服务器地址等。</p></blockquote><ul><li>如下图，在本机使用<code>ipconfig</code>命令即可查看网络配置。</li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027193318662.png" style="zoom: 67%;"></p><p>对于一个新到达的主机，DHCP协议分为四步分配地址：</p><p><strong>1.DHCP服务器发现</strong></p><ul><li>通过使用DHCP发现报文实现。客户端在UDP分组中向端口67发送该报文。UDP分组封装在IP数据报中，使用广播目的地址<code>255.255.255.255</code>，将IP数据报传递给链路层，然后广播到子网连接的节点。</li></ul><p><strong>2.DHCP服务器提供</strong></p><ul><li>DHCP服务器收到DHCP发现报文，用<strong>DHCP提供报文</strong>响应客户端。仍用<code>255.255.255.255</code>向子网所有节点广播。</li><li>子网可能存在多个DHCP服务器，因此服务器报文中包含发现报文的<strong>事务ID</strong>、推荐给客户端的<strong>IP地址</strong>、<strong>网络掩码</strong>、IP地址<strong>租用期</strong>（IP地址有效时间，一般为几小时-几天）。</li></ul><p><strong>3.DHCP请求</strong></p><ul><li>客户端从一个或多个服务器提供中选择一个，并向选中的服务器提供<strong>DHCP请求报文</strong>，回显配置的参数。</li></ul><p><strong>4.DHCP ACK</strong></p><ul><li>服务器用<strong>DHCP ACK报文</strong>对DHCP请求进行响应，证实所求参数。</li></ul><p>客户端收到<strong>ACK</strong>后，交互完成。</p><hr><p><strong>网络地址转换</strong></p><blockquote><p>地址空间<code>10.0.0.0/8</code>是在[RFC 1918]中保留的三部分IP地址空间之一，这些地址用于下图等<strong>专用网络</strong>或具有专用地址的地域。</p><p><strong>具有专用地址的地域</strong>是指其地址仅对该网络中的设备有意义的网络。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027194912842.png" alt=""></p><ul><li><p>NAT使能路由器对于外部世界来说行为就如同具有单一IP地址的单一设备。</p><ul><li>上图所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址<code>138.76.29.7</code>,且所有进入家庭的报文都拥有同一个目的IP地址<code>138.76.29.7</code>。</li><li>NAT使能路由器对外界隐藏了家庭网络的细节。</li></ul></li><li><p>通过<strong>NAT转换表</strong>(NAT translation table)，路由器知道将分组转发给哪个内部主机。</p></li></ul><hr><p><strong>IPV6</strong></p><blockquote><p>IPV6数据报格式入下图。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027195610223.png" alt=""></p><ul><li><strong>扩大的地址容量：</strong>128bits。</li><li><strong>40字节定长首部：</strong>允许路由器更快地处理数据。</li><li><strong>流标签：</strong>流（flow）。该字段用于“给属于特殊流（发送方要求特殊处理）的分组加上标签”。</li><li><strong>下一个首部(Next hdr)：</strong>标识数据报中内容需要交付给哪个协议（如TCP或UDP）。</li><li><strong>跳限制(Hop limit)：</strong>转发数据报的每台路由器将该字段-1。如果计数为0，则丢弃。</li></ul><hr><h3 id="2-控制平面"><a href="#2-控制平面" class="headerlink" title="2.控制平面"></a>2.控制平面</h3><h4 id="2-1路由选择算法"><a href="#2-1路由选择算法" class="headerlink" title="2.1路由选择算法"></a>2.1路由选择算法</h4><blockquote><p>从发送方到接受方确定一条通过路由器网络的最佳路径。</p></blockquote><ul><li><p>路由选择算法的一种分类方式：</p><ul><li><p><strong>集中式路由选择算法：</strong>用完整的、全局性的网络知识计算出从源地址到目的地址的最低开销路径。该算法以所有节点之间的<strong>连通性</strong>和所有链路的<strong>开销</strong>作为输入。</p><p>具有全局状态信息的算法通常称为<strong>链路状态(Link State, LS)算法</strong>。</p></li><li><p><strong>分散式路由选择算法：</strong>路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。每个节点仅有直接相连的链路开销信息即可工作。</p></li></ul></li><li><p>第二种分类方式：</p><ul><li><strong>静态路由选择算法：</strong>路由随时间变化非常缓慢，通常人工进行调整（人工编辑链路开销）。</li><li><strong>动态路由选择算法：</strong>随着网络流量负载或拓扑发生变化而改变路由选择路径。易受选择循环、路由震荡之类问题的影响。</li></ul></li><li><p>第三种分类方式：</p><ul><li><strong>负载敏感算法：</strong>链路开销会动态变化以反映底层链路的拥塞水平。</li><li><strong>负载迟钝算法：</strong>链路开销不反映拥塞水平</li></ul></li></ul><hr><p><strong>链路状态路由选择算法</strong></p><blockquote><p>通过每个节点向网络中所有其他节点广播链路状态分组（链路标识和开销）来确定所有链路开销。</p><p>节点广播的结果是所有节点都具有该网络统一、完整的视图。</p></blockquote><p><code>Disjkstra</code>算法</p><pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">Initialization:N’ = {u}    for all nodes v    if v is a neighbor of u    then D(v) = c(u, v)    else     D(v) = ∞Loop    find w not in N’ such that D(w) is a minimum    add w to N’    update D(v) for each neighbor v of w and not in N’:    D(v) = min(D(v), D(w)+ c(w, v) )    /* new cost to v is either old cost to v or known       least path cost to w plus cost from w to v */until N’= N<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211114094249391.png" style="zoom:50%;"></p><hr><p><strong>距离向量路由选择算法</strong></p><blockquote><p>是一种迭代的、异步的、分布式的算法。</p><p><strong>分布式</strong>：每个节点从一个或多个直接相连邻居接收信息，执行计算，将结果分发给邻居。</p><p><strong>迭代</strong>：过程一直持续到邻居之间无更多信息交换为止。</p><p><strong>异步</strong>：不要求所有节点相互之间操作一致。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File I/O</title>
      <link href="/2021/10/26/file-io/"/>
      <url>/2021/10/26/file-io/</url>
      
        <content type="html"><![CDATA[<h2 id="File-IO"><a href="#File-IO" class="headerlink" title="File IO"></a>File IO</h2><blockquote><p>UNIX系统上的大多数文件I/O只能使用5个函数来执行:open、read、write、lseek和close，这些函数通常被称为无缓冲I/O，</p></blockquote><h3 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1.文件描述符"></a>1.文件描述符</h3><blockquote><p>对于内核，所有打开的文件都由文件描述符引用。文件描述符是非负整数。 </p></blockquote><ul><li>当我们打开一个现有文件或创建一个新文件时，内核会向进程返回一个文件描述符。</li><li>当我们想要读或写一个文件时，我们用<code>open</code>或<code>create</code>返回的文件描述符作为参数来标识该文件。</li></ul><blockquote><p>按照惯例，UNIX系统shell将0对应标准输入<code>STDIN_FILENO</code>，将1对应标准输出<code>STDOUT_FILENO</code>，将2对应标准错误输出<code>STDERR_FILENO</code>。</p></blockquote><ul><li>文件描述符的范围从0到<code>OPEN_MAX−1</code>。</li></ul><h3 id="2-文件IO函数"><a href="#2-文件IO函数" class="headerlink" title="2.文件IO函数"></a>2.文件IO函数</h3><h4 id="2-1-open函数"><a href="#2-1-open函数" class="headerlink" title="2.1 open函数"></a>2.1 <code>open</code>函数</h4><blockquote><p>通过调用<code>open</code>函数或<code>openat</code>函数打开或创建文件。 </p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* mode_t mode */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">openat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* mode_t mode */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>Both <span class="token keyword">return</span><span class="token operator">:</span> file descriptor <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>最后一个参数显示为…，这是指定其余参数的数量和类型可能不同。</p></li><li><p>对于这些函数，最后一个参数仅在创建新文件时使用</p></li><li><p><code>path</code>参数是要打开或创建的文件的名称。</p><ul><li><p>这个函数有许多选项，由<code>oflag</code>参数指定。这个参数由<code>&lt;fcntl.h&gt;</code>头文件中的一个或多个常量组成:</p><pre class="line-numbers language-none"><code class="language-none">O_RDONLY Open for reading only.O_WRONLY Open for writing only.O_RDWR Open for reading and writing.O_EXEC Open for execute only.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为了与旧程序兼容，大多数实现将<code>O_RDONLY</code>定义为0,<code>O_WRONLY</code>定义为1,<code>O_RDWR</code>定义为2。</p></li><li><p>前五个常量中只有一个必须指定。以下常量是可选的:</p><pre class="line-numbers language-none"><code class="language-none">O_APPEND 在每次写入时附加到文件末尾。O_CLOEXEC 设置FD_CLOEXEC文件描述符标志。O_CREAT 如果文件不存在，则创建该文件。O_DIRECTORY 如果路径没有指向目录，则生成错误。O_EXCL 如果指定了O_CREAT并且文件已经存在，则生成一个错误。O_NOFOLLOW 如果路径指向符号链接，则生成错误。O_NONBLOCK  此选项为打开文件和随后的I/O设置非阻塞模式。O_TRUNC 如果文件存在，并且成功地以只写或读写的方式打开，则将其长度截断为0。O_SYNC 让每个写操作等待物理I/O完成，包括更新由于写操作而修改的文件属性所需的I/O。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>下面两个标志也是可选的。它们是同步输入和输出选项的一部分</p><pre class="line-numbers language-none"><code class="language-none">O_DSYNC 让每次写入等待物理I/O完成，但如果文件属性不影响读取刚刚写入的数据的能力，就不要等待文件属性的更新。O_RSYNC 让文件描述符上的每个读操作都等待，直到文件同一部分的任何挂起的写操作完成。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p><code>open</code>和<code>openat</code>返回的文件描述符<code>fd</code>保证是编号最低的未使用描述符。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache工作原理</title>
      <link href="/2021/10/26/cache-gong-zuo-yuan-li/"/>
      <url>/2021/10/26/cache-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h2><h3 id="1-Cache基本概念"><a href="#1-Cache基本概念" class="headerlink" title="1. Cache基本概念"></a>1. Cache基本概念</h3><blockquote><p>为提升CPU访问主存的性能，通常会在CPU和主存之间增加一个隐藏的小容量快速<code>SRAM</code>，称为 <code>cache</code>。将主存中经常访问或即将访问的数据的副本调度到小容量的 <code>SRAM</code> 中，使得大部分数据访问都可以在其中进行，从而提升性能。</p></blockquote><ul><li>CPU通过字节地址访问快速的 <code>cache</code>，通过一定查找机制判断数据是否在 <code>cache</code> 中<ul><li>如果数据在 <code>cache</code> 中，则称为<strong>数据命中（cache hit）</strong>，<strong>命中访问时间</strong>为 $t_c$，包括查找时间和 <code>cache</code> 访问时间</li><li>如果数据不在 <code>cache</code> 中，则称为<strong>数据丢失（cache miss）</strong>，需要将缺失的数据从主存调入 <code>cache</code> 中；数据缺失的访问时间称为<strong>缺失补偿（miss penalty）</strong>，包括数据查找时间、主存访问时间、<code>cache</code> 访问时间，通常用主存访问时间 $t_m$ 表示。</li></ul></li><li>为了便于比较和快速查找，<code>cache</code> 和主存都被分成若干个固定大小的<strong>块</strong>，每个块包含若干<strong>字</strong>，数据缺失时将<strong>数据所在块</strong>载入 <code>cache</code> 中 [这种预读策略可以充分利用空间局部性，提高顺序访问的命中概率]。<ul><li>块过小无法使<strong>预读策略</strong>优化<a href="#2. 程序局部性">空间局部性</a>，块过大使<strong>替换算法</strong>无法利用<a href="#2. 程序局部性">时间局部性</a>。</li></ul></li><li>数据分块后，地址可以分为<strong>块地址</strong>和<strong>偏移地址</strong>， <code>cache</code> 容量较小，因此主存地址字段长度大于 <code>cache</code> 地址字段长度。</li></ul><p><strong>命中率</strong>（评价 <code>cache</code> 性能）</p><ul><li><p>设 $N_c$ 为运行期间命中 <code>cache</code> 次数，$N_m$ 为从主存访问次数，命中率 $h$ 为：</p><script type="math/tex; mode=display">h = \frac{N_c}{N_c+N_m}, \;\;h\rightarrow1,\;性能越好</script><p>$1-h$ 称为<strong>缺失率</strong>。</p></li><li><p>$t_c$ 表示命中访问时间，$t_m$ 表示缺失访问时间，平均访问时间 $t_a$ 为</p><script type="math/tex; mode=display">t_a=ht_c+(1-h)t_m,\;\;cache 目的是使t_a\rightarrow t_c</script><p> $e=t_c/t_a$ 为<strong>访问效率</strong>，$r=t_m/t_c$ 为主存相对 <code>caceh</code> 访问时间的倍数，</p><script type="math/tex; mode=display">e=\frac{t_c}{t_a}=\frac{1}{h+(1-h)r}</script><p>显然访问效率 $e $ 与 $r$ 和 $h$ 中有关。</p></li></ul><hr><h3 id="2-程序局部性"><a href="#2-程序局部性" class="headerlink" title="2. 程序局部性"></a>2. 程序局部性</h3><blockquote><p><strong>时间局部性</strong>：当程序访问一个存储位置时，该位置在未来可能会被多次访问。比如程序的循环结构和调用过程。</p><p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，则其附近的存储单元也即将被访问。如指令代码、数组、结构体等顺序存放的结构。</p></blockquote><hr><h3 id="3-Cache-读写流程"><a href="#3-Cache-读写流程" class="headerlink" title="3.  Cache 读写流程"></a>3.  <code>Cache</code> 读写流程</h3><p><code>Cache</code> 读流程较为简单，略过。</p><p><code>Cache</code> 写流程：</p><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026151655241.png" style="zoom:67%;"></p><p>数据缺失时有两种不同策略：</p><ul><li>若为<strong><a href="#6. 写入策略">写分配法</a></strong>，则需将 <code>WA</code> 对应的数据块载入 <code>Cache</code> 中，再进行写命中相同流程。</li><li>若不为写分配法，则将数据写入主存即返回。</li></ul><p>新写入 <code>Cache</code> 的数据域主存数据不一致，称为<strong>脏数据</strong>。</p><p>数据写入完成后：</p><ul><li>若为<strong>写回策略</strong>，则写入操作结束，这种方式响应最快，但会产生不一致性。</li><li>若为<strong>写穿策略</strong>，则需将脏数据写入主存后返回，响应速度慢，但不会产生不一致性。</li></ul><p><code>Cache</code> 实现的关键技术</p><ol><li>数据查找：快速判断数据是否在 <code>Cache</code> 中</li><li>地址映射：主存数据块如何放置到 <code>Cache</code> 中</li><li>替换策略： <code>Cache</code> 满后如何替换数据块</li><li>写入策略：如何保证 <code>Cache</code> 与主存一致性</li></ol><hr><h3 id="4-地址映射"><a href="#4-地址映射" class="headerlink" title="4. 地址映射"></a>4. 地址映射</h3><blockquote><p>将主存地址空间映射到 <code>Cache</code> 地址空间，即载入 <code>Cache</code> 块的规则。</p><ul><li><strong>全相联</strong>：主存块可以映射到 <code>Cache</code> 任意数据块</li><li><strong>直接相联</strong>：主存块只能映射到 <code>Cache</code> 中固定块</li><li><strong>组相联</strong>：主存块只能映射到 <code>Cache</code> 固定组中的任意块</li></ul></blockquote><h4 id="4-1-全相联映射"><a href="#4-1-全相联映射" class="headerlink" title="4.1 全相联映射"></a>4.1 全相联映射</h4><blockquote><p>新的主存块可以载入 <code>Cache</code> 中任何一个空位置，只有 <code>Cache</code> 满时才进行数据块置换。</p><p> <code>Cache</code> 利用率最高，查找成本较高，CAM提供查找功能。</p></blockquote><ul><li>由于主存块可以放置在任意块中，为方便查找，需记录 有效位、主存块地址标记、脏数据标志位、淘汰计数等。</li><li>通常将一个 <code>Cache</code> 数据块和标志信息一起称为一个 <code>Cache</code>行/槽，有多少 <code>Cache</code> 数据块对应有多少 <code>Cache</code> 行。</li></ul><blockquote><p>主存地址划分为块地址(<strong>tag</strong>)和块内偏移地址(<strong>offset</strong>)两部分，长度分别为 $s,w$， <code>Cache</code> 块大小为 $2^w$ 字节， <code>Cache</code> 缓冲区容量为 $n\times 2^w$ 字节，只考虑有效位和主存块地址， <code>Cache</code> 实际容量为 $n\times (1+s+8\times 2^w)$，主存容量为 $2^{s+w}$ 字节。</p></blockquote><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026154708162.png" style="zoom:67%;"></p><p>全相联映射访问过程：主存 <code>tag</code> 字段将与所以行中 <code>tag</code> 字段进行比较</p><ul><li><code>valid</code> 有效位必须设置为1</li><li><code>tag</code> 必须与主存 <code>tag</code> 匹配</li><li>3位 <code>offset</code> 决定选中哪一个字</li></ul><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026155124123.png" alt=""></p><blockquote><p>全相联映射方式特点：</p><ul><li>主存块映射到  <code>Cache</code> 任意一行， <code>Cache</code> 利用率高</li><li><code>Cache</code> 有空行就可以插入， <code>Cache</code> 冲突率低</li><li>查找需要并发查找每一行，硬件成本高，只适合小容量 <code>Cache</code> </li><li><code>Cache</code> 满时需进行替换，替换算法复杂</li></ul></blockquote><hr><h4 id="4-2-直接相联映射"><a href="#4-2-直接相联映射" class="headerlink" title="4.2 直接相联映射"></a>4.2 直接相联映射</h4><blockquote><p>每一个主存地址只能映射到 <code>Cache</code> 固定行，映射规则为：</p><p>$cache 行号\;i=主存块号\; j\mod(cache 行数 \;n)$ </p><p>等效于将<strong>主存块</strong>分为与 <code>Cache</code> 行数相同的分区，因此主存地址分为：区地址 [<code>tag</code>]，区内行索引 [<code>index</code>]，块内偏移地址 [<code>offset</code>]。</p></blockquote><p>直接相联映射访问过程：</p><ul><li><code>index</code> 字段选中对应的 <code>Cache</code> 行 </li><li><code>valid</code> 有效位必须设置为1</li><li><code>tag</code> 必须与主存 <code>tag</code> 匹配</li><li>3位 <code>offset</code> 决定选中哪一个字</li></ul><blockquote><p>直接相联映射的特点：</p><ul><li>主存块只能映射到  <code>Cache</code> 中固定行， <code>Cache</code> 利用率低，命中率低</li><li><code>index</code> 相同的主存块映射 <code>Cache</code> 同一行， <code>Cache</code> 冲突率高 [小声bb：冲突率高不就是利用率低吗，跟第一条差不多]</li><li>查找只需与对应行的标记字段 <code>tag</code> 进行比较，硬件成本低</li><li>无须使用复杂替换算法</li></ul></blockquote><hr><h4 id="4-3-组相联映射"><a href="#4-3-组相联映射" class="headerlink" title="4.3 组相联映射"></a>4.3 组相联映射</h4><blockquote><p> <code>Cache</code> 分成固定大小的组，每组有 $k$ 行，称为 $k-$路组相联，主存数据先采用<strong>直接相联映射</strong>定位到 <code>Cache</code> 固定的组，再采用<strong>全相联映射</strong>到组内任意 <code>Cache</code> 行。组相联映射规则：</p><p>$cache \; 组号=主存块号\mod (cache组数)$ </p></blockquote><p> <code>Cache</code> 模型：</p><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026160747150.png" style="zoom:67%;"></p><p> 组相联<code>Cache</code>映射方式： </p><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026160910295.png" style="zoom:67%;"></p><p>组相联映射访问过程：</p><ul><li><code>index</code> 字段选中对应的 <code>Cache</code> 行 <ul><li>组中的任何一行都可以包含映射到这个组的任何内存块。 因此缓存必须搜索组中的每一行，搜索其标记与地址中的标记匹配的有效行。 如果缓存找到这样的一行，那么就有一个 hit。</li></ul></li><li><code>valid</code> 有效位必须设置为1</li><li><code>tag</code> 必须与主存 <code>tag</code> 匹配</li><li>3位 <code>offset</code> 决定选中哪一个字</li></ul><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026161308510.png" alt=""></p><blockquote><p>组相联映射的特点：</p><ul><li>每一组多路比较器大幅减少，为各 <code>Cache</code> 共享，硬件成本更低</li><li>每组只有一个 <code>Cache</code> 行时，变成直接相联映射</li><li>整个 <code>Cache</code> 只有一组时，变成全相联映射</li></ul></blockquote><hr><h3 id="5-替换算法"><a href="#5-替换算法" class="headerlink" title="5. 替换算法"></a>5. 替换算法</h3><blockquote><p>替换算法与 <code>Cache</code> 组织方式相关：</p><p>直接相联映射不需要替换算法，因为一个主存块只能存放在一个特定行；</p><p>全相联映射执行替换算法时涉及所有行；</p><p>组相联映射执行替换算法设计特定组的所有行。</p></blockquote><h4 id="5-1-FIFO算法"><a href="#5-1-FIFO算法" class="headerlink" title="5.1 FIFO算法"></a>5.1 FIFO算法</h4><blockquote><p><strong>先进先出算法</strong>按照数据块进入 <code>Cache</code> 先后决定替换顺序，需要替换时，最先被载入的 <code>Cache</code> 行被替换。</p><p>需记录每个 <code>Cache</code> 行载入 <code>Cache</code> 的时间戳</p><p>特点：</p><ul><li>系统开销较小，但不考虑程序访问的局部性，有可能导致 <code>Cache</code> 命中率低</li></ul></blockquote><h4 id="5-2-LFU算法"><a href="#5-2-LFU算法" class="headerlink" title="5.2 LFU算法"></a>5.2 LFU算法</h4><blockquote><p><strong>最不经常使用算法</strong>将访问次数最少的 <code>Cache</code> 行替换，每行需设置淘汰计数器，新载入 <code>Cache</code> 行为0，每命中一次计数器+1，替换时对所有可能替换行的计数值比较，<strong>计数值最小</strong>的替换。</p><p>特点：</p><ul><li>计数器统计 <code>Cache</code> 启动后至今的访问次数，不能反映近期访问情况。</li></ul></blockquote><h4 id="5-3-LRU算法"><a href="#5-3-LRU算法" class="headerlink" title="5.3 LRU算法"></a>5.3 LRU算法</h4><blockquote><p><strong>近期最少使用算法</strong>将近期最久未访问的 <code>Cache</code> 行进行替换。也需设置计数器， <code>Cache</code> 命中行计数器清0，其余行+1，替换时对所有可能替换行的计数值比较，<strong>计数值最大</strong>的替换。</p><p>特点：</p><ul><li>保护了刚载入 <code>Cache</code> 的新数据，符合<code>Cache</code> 工作原理，有较高命中率。</li><li>实现难点为比较多行计数器，2-路组相联 <code>Cache</code> 能大大简化情况。</li></ul></blockquote><h4 id="5-4-随机替换算法"><a href="#5-4-随机替换算法" class="headerlink" title="5.4 随机替换算法"></a>5.4 随机替换算法</h4><blockquote><p> <strong>随机替换算法</strong>对特定的行中随机选取一行进行替换。</p><p>特点：</p><ul><li>硬件实现最容易，速度快。</li><li>随意换出的数据可能即将访问，降低命中率。负面影响随着 <code>Cache</code> 增大而减小。</li></ul></blockquote><hr><h3 id="6-写入策略"><a href="#6-写入策略" class="headerlink" title="6. 写入策略"></a>6. 写入策略</h3><h4 id="写回法（Write-Back）"><a href="#写回法（Write-Back）" class="headerlink" title="写回法（Write-Back）"></a>写回法（Write-Back）</h4><blockquote><p>CPU对 <code>Cache</code> 写命中时，只修改 <code>Cache</code> 内容，不立即写入主存，只有此行被替换时才将脏数据写回主存。</p></blockquote><ul><li>这种策略使 <code>Cache</code> 在读写操作均起到高速缓存作用。</li><li>每个 <code>Cache</code> 行必须有一个修改位，即脏位（dirty bit），改写过则为1，未改写则为0</li><li>由于不一致性，DMA操作可能获得的是旧数据</li></ul><h4 id="写穿法（Write-Through）"><a href="#写穿法（Write-Through）" class="headerlink" title="写穿法（Write-Through）"></a>写穿法（Write-Through）</h4><blockquote><p>又称直写法， <code>Cache</code> 命中时，同时对 <code>Cache</code> 和主存中同一数据块进行修改。 <code>Cache</code> 无需脏位，替换时可直接替换。</p></blockquote><ul><li>在多核CPU下，每个核都有对应 <code>Cache</code> ，因此即使写穿法也无法保证 <code>Cache</code> 同步更新。</li></ul><hr><p>以上就是关于 <code>Cache</code> 的全部内容，若还有知识点再进行补充。</p><hr><p>参考：</p><p>计算机组成原理（微课版），大萝卜</p><p>CSAPP（3rd edition）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 线程模型</title>
      <link href="/2021/10/24/netty-xian-cheng-mo-xing/"/>
      <url>/2021/10/24/netty-xian-cheng-mo-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO</title>
      <link href="/2021/10/24/java-nio/"/>
      <url>/2021/10/24/java-nio/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><blockquote><p>首先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型: </p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Excutors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPollExecutor</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//线程池</span>    <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 主线程死循环等待新连接到来</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>currentThread<span class="token punctuation">.</span><span class="token function">isInturrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment">// 接受新的socket</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 为新的连接创建新的线程</span>        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConnectIOnHandler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConnectIOnHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">ConnectIOnHandler</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> socket<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 死循环处理读写事件</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>currentThread<span class="token punctuation">.</span><span class="token function">isInturrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>socket<span class="token punctuation">.</span><span class="token function">isClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 读取数据</span>            <span class="token class-name">String</span> someThing <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>someThing<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment">// 处理数据</span>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                    <span class="token comment">// 写数据</span>                    socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/10/24/java-nio/image-20211024112633666.png" alt="" style="zoom:50%;"></p><blockquote><p>这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于 <code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code>三个主要函数都是同步阻塞的，当一个连接在处理 I/O 的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里。</p><p>这也是为什么在做计网实验的时候单线程只能处理一次请求，如果再次发出请求服务器根本不会响应，因为服务器被阻塞在读写了。</p></blockquote><ul><li>多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单。</li></ul><p>这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：</p><ol><li>线程的创建和销毁成本很高</li><li>线程本身占用较大内存</li><li>线程的切换成本很高</li></ol><hr><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>传统的BIO里面 <code>socket.read()</code>，如果TCP <code>RecvBuffer</code> 里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP <code>RecvBuffer</code>有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。(解释地真地道)</p><blockquote><p>NIO<strong>只有在连接/通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，这就大大地减少了系统的开销。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">NIO的核心</th><th style="text-align:left">对应的类或接口</th><th style="text-align:left">应用</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">缓冲区</td><td style="text-align:left"><code>Buffer</code></td><td style="text-align:left">文件IO/网络IO</td><td style="text-align:left">存储数据</td></tr><tr><td style="text-align:left">通道</td><td style="text-align:left"><code>Channel</code></td><td style="text-align:left">文件IO/网络IO</td><td style="text-align:left">运输</td></tr><tr><td style="text-align:left">选择器</td><td style="text-align:left"><code>Selector</code></td><td style="text-align:left">网络IO</td><td style="text-align:left">控制器</td></tr></tbody></table></div><h3 id="单线程-Reactor"><a href="#单线程-Reactor" class="headerlink" title="单线程 Reactor"></a><strong>单线程 <code>Reactor</code></strong></h3><blockquote><p><code>Reactor</code> 模型中定义的三种角色：</p></blockquote><ul><li><code>Reactor</code> ：负责监听和分配事件，将I/O事件分派给对应的 <code>Handler</code>。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li><code>Acceptor</code>：处理客户端新连接，并分派请求到处理器链中。</li><li><code>Handler</code>：将自身与事件绑定，执行非阻塞读/写任务，完成 <code>channel</code> 的读入，完成处理业务逻辑后，负责将结果写出 <code>channel</code>。可用资源池来管理。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">ChannelHandler</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">channelReadable</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">channelWritable</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Channel</span><span class="token punctuation">{</span>    <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>    <span class="token class-name">Event</span> event<span class="token punctuation">;</span><span class="token comment">//读，写或者连接</span><span class="token punctuation">}</span><span class="token comment">//IO线程主循环:</span><span class="token keyword">class</span> <span class="token class-name">IoThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel<span class="token punctuation">;</span>        <span class="token comment">//选择就绪的事件和对应的连接</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>channel<span class="token operator">=</span><span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>accept<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果是新连接，则注册一个新的读写处理器</span>                <span class="token function">registerNewChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>write<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果可以写，则执行写事件</span>                <span class="token function">getChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channelWritable</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>read<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果可以读，则执行读事件</span>                <span class="token function">getChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channelReadable</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//所有channel的对应事件处理器</span>    <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Channel</span>，<span class="token class-name">ChannelHandler</span><span class="token operator">&gt;</span> handlerMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这也是最简单的 <code>Reactor</code> 模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。 </p><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p></blockquote><p><img src="/2021/10/24/java-nio/image-20211021165753294-16350547783021.png" alt="" style="zoom:40%;"></p><p><code>Reactor</code> 处理请求的流程：</p><ol><li><code>Reactor</code> 对象通过 <code>select</code> 监控连接事件，收到事件后通过 <code>dispatch</code> 进行转发。</li><li>如果是连接建立的事件，则由 <code>acceptor</code> 接受连接，并创建 <code>handler</code> 处理后续事件。</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用 <code>Handler</code> 来响应。</li><li><code>handler</code> 会完成 <code>read</code> <code>-&gt;</code> 业务处理 <code>-&gt;</code> <code>send</code> 的完整业务流程。</li></ol><blockquote><p><strong>单线程模式的缺点:</strong></p><ol><li>当其中某个 <code>handler</code> 阻塞时， 会导致其他所有的 client 的 <code>handler</code> 都得不到执行， 并且更严重的是， <code>handler</code> 的阻塞也会导致整个服务不能接收新的 client 请求(因为 <code>acceptor</code> 也被阻塞了)。</li></ol></blockquote><h3 id="多线程-Reactor"><a href="#多线程-Reactor" class="headerlink" title="多线程 Reactor"></a><strong>多线程 <code>Reactor</code></strong></h3><blockquote><p>连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。</p><p>在线程 <code>Reactor</code> 模式基础上，做如下改进：</p><p>（1）将 <code>Handler</code> 处理器的执行放入线程池，多线程进行业务处理。 </p><p>（2）而对于 <code>Reactor</code> 而言，可以仍为单个线程。如果服务器为多核的CPU，为充分利用系统资源，可以将 <code>Reactor</code> 拆分为两个线程。</p></blockquote><p><img src="/2021/10/24/java-nio/v2-22efc734724d07251f8293e2f1143639_720w.png" alt="" style="zoom: 67%;"></p><p>下图是 <code>netty in action</code> 中关于NIO的流程图。</p><p><img src="/2021/10/24/java-nio/image-20211022204547930.png" alt=""></p><p>多线程 <code>Reactor</code> 消息处理流程：</p><ol><li>从主线程池中随机选择一个 <code>Reactor</code> 线程作为 <code>acceptor</code> 线程，用于绑定监听端口，接收客户端连接</li><li><code>acceptor</code> 线程接收客户端连接请求之后创建新的 <code>SocketChannel</code>，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作</li><li>步骤2完成之后，业务层的链路正式建立，将 <code>SocketChannel</code> 从主线程池的 <code>Reactor</code> 线程的多路复用器上摘除，重新注册到Sub线程池的线程上，并创建一个 <code>Handler</code> 用于处理各种连接事件</li><li>当有新的事件发生时，<code>SubReactor</code> 会调用连接对应的 <code>Handler</code> 进行响应</li><li><code>Handler</code> 通过 <code>Read</code> 读取数据后，会分发给后面的 <code>Worker</code> 线程池进行业务处理</li><li><code>Worker</code> 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 <code>Handler</code> 进行处理</li><li><code>Handler</code> 收到响应结果后通过 <code>Send</code> 将响应结果返回给 <code>Client</code> </li></ol><p><img src="/2021/10/24/java-nio/image-20211024141840397.png" alt="" style="zoom:50%;"></p><blockquote><p><code>Reactor</code> 模式在 IO 读写数据时还是在同一个线程中实现的，即使使用多个 <code>Reactor</code> 机制的情况下，那些共享一个 <code>Reactor</code> 的 <code>Channel</code> 如果出现一个<strong>长时间的数据读写</strong>，会影响这个 <code>Reactor</code> 中其他<code>Channel</code> 的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的 <code>Thread-Per-Connection</code> 或许是一个更好的选择，或则此时使用改进版的<code>Reactor</code> 模式如 <code>Proactor</code> 模式。</p></blockquote><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a><code>Proactor</code></h3><blockquote><p><code>Reactor</code> 模型用于同步I/O，而 <code>Proactor</code> 模型运用于异步I/O操作。 </p></blockquote><p><strong>模型</strong></p><p><img src="/2021/10/24/java-nio/v2-35bd4bdf3b12246fb005415d3a29ecc0_r.jpg" alt=""></p><p><strong>模块关系</strong> </p><ol><li><code>Procator Initiator</code>负责创建<code>Procator</code>和<code>Handler</code>，并将<code>Procato</code>r和<code>Handler</code>都通过<code>Asynchronous operation processor</code>注册到内核。</li><li><code>Asynchronous operation processor</code>负责处理注册请求，并完成IO操作。完成IO操作后会通知<code>procator</code>。</li><li><code>procator</code>根据不同的事件类型回调不同的<code>handler</code>进行业务处理。<code>handler</code>完成业务处理，<code>handler</code>也可以注册新的<code>handler</code>到内核进程。</li></ol><p>消息处理流程：</p><p><strong>读取</strong>操作：</p><ol><li>应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。</li><li>事件分离器等待读取操作完成事件。</li><li>在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将数据读写到<strong>应用传递进来的缓冲区</strong>(如Netty中的<code>ByteBuf</code>)中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。</li><li>事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</li></ol><blockquote><p>异步IO都是操作系统负责将数据读写到<strong>应用传递进来的缓冲区</strong>供应用程序操作。</p></blockquote><p>Proactor中写入操作和读取操作，只不过感兴趣的事件是完成事件。</p><blockquote><p>在 Linux 下的异步 I/O 是不完善的， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p></blockquote><hr><h4 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h4><p>Netty采用的是<strong>主从线程模型</strong>。下面是Netty使用中很常见的一段代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">EventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">EventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token annotation punctuation">@Override</span>                 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpServerCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpObjectAggregator</span><span class="token punctuation">(</span><span class="token number">65536</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChunkedWriteHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpStaticFileServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">Channel</span> ch <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             ch<span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义了两个<code>EventLoopGroup</code>，其中<code>bossGroup</code>对应的就是主线程池，只接收客户端的连接（注册，初始化逻辑），具体的工作由<code>workerGroup</code>这个从线程池来完成。</li><li>客户端和服务器建立连接后，NIO会在两者之间建立<code>Channel</code>，所以启动类调用<code>channel</code>方法就是为了指定建立什么类型的通道。</li><li>启动类还调用了<code>handler()</code>和<code>childHandler()</code>方法，这两个方法中提及的<code>handler</code>是一个处理类的概念，他负责处理连接后的一个个<code>Channel</code>的相应处理。<code>handler()</code>指定的处理类是主线程池中对通道的处理类，<code>childHandler()</code>方法指定的是从线程池中对通道的处理类。<ul><li>Netty中，可以注册多个<code>handler</code>。<code>ChannelInboundHandler</code>按照注册的先后顺序执行；<code>ChannelOutboundHandler</code>按照注册的先后顺序逆序执行</li></ul></li></ul><blockquote><p>如果需要在客户端连接前的请求进行<code>handler</code>处理，则需要配置<code>handler()</code>；如果是处理客户端连接之后的<code>handler</code>，则需要配置在<code>childHandler()</code>。</p></blockquote><p><strong>Netty三大组件</strong></p><p><code>Channel</code>接口提供了一个API，大大降低了直接使用<code>Sockets</code>的复杂性。当创建<code>Channel</code>时，它会自动分配自己的<code>ChannelPipeline</code>。<code>ChannelPipeline</code>中含有一些<code>ChannelHandlers</code>，用于用户自定义处理事件。数据通过<code>Channel</code>在各个<code>Handler</code>之间流动。</p><p><img src="/2021/10/24/java-nio/image-20211024185955001.png" alt=""></p><p><code>EventLoop</code>定义了Netty的核心抽象，用于处理在连接生命周期内发生的事件。<code>Channel</code>在其生命周期内注册为一个<code>EventLoop</code>。一个<code>EventLoop</code>可以被分配给一个或多个<code>Channel</code>。</p><p>关系如下图所示：</p><p><img src="/2021/10/24/java-nio/image-20211024185355812.png" alt=""></p><p>Netty中的所有I/O操作都是<strong>异步</strong>的。因为一个操作可能不会立即返回，所以我们需要一种方法在以后确定它的结果。为此，Netty提供了<code>ChannelFuture</code>，其<code>addListener()</code>方法注册一个<code>ChannelFutureListener</code>，当<strong>操作完成时通知</strong>它(无论是否成功)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">channelFuture<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelProgressiveFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationProgressed</span><span class="token punctuation">(</span><span class="token class-name">ChannelProgressiveFuture</span> future<span class="token punctuation">,</span> <span class="token keyword">long</span> progress<span class="token punctuation">,</span> <span class="token keyword">long</span> total<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// total unknown</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer progress: "</span> <span class="token operator">+</span> progress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer progress: "</span> <span class="token operator">+</span> progress <span class="token operator">+</span> <span class="token string">" / "</span> <span class="token operator">+</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelProgressiveFuture</span> future<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer complete."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码就是通过添加 <code>FutureListener</code> 实现I/O操作完成后在Console中打印信息的功能。</p><hr><p>参考：</p><p>Netty In Action</p><p><a href="https://zhuanlan.zhihu.com/p/23488863">Java NIO浅析 - 知乎 (zhihu.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1573934">netty Reactor模式（源码死磕 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p><a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署问题</title>
      <link href="/2021/10/23/deploy-problem/"/>
      <url>/2021/10/23/deploy-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo部署到github上遇到的问题"><a href="#Hexo部署到github上遇到的问题" class="headerlink" title="Hexo部署到github上遇到的问题"></a>Hexo部署到github上遇到的问题</h2><ul><li>按照正常流程操作<ul><li>下载node，npm，git等工具</li><li>创建一个合法名字的github仓库</li><li>用 <code>npm install hexo -g</code> 安装hexo</li><li><code>hexo init + npm install</code> 初始化并安装必要组件</li><li><code>hexo g</code> 生成 <code>hexo s</code> 本地预览</li><li><code>hexo d</code> 部署到github上</li></ul></li></ul><p>然后就发现，github上根本不显示我上传的网页。大一那会还什么都不懂，调试了三天都还是错的，最后稀里糊涂地才能访问。<br>其实就是在 <code>_config.yml</code> 文件中：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">deploy:  type: git  repository: git@github.com:Maoshengren/Maoshengren.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不能用 <code>master</code> 分支，需要改成 <code>main</code>。 在github上检查发现文件都已经上传上去了，只是显示的问题，所以肯定是部署错误了，一个是配置中的 <code>url</code> 可能不对</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: http://Maoshengren.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个是我发现我所在的分支名称是 <code>main</code> 而不是<code>master</code>，将这些改好后再次访问我的网站就成功。</p><ul><li>大一刚入学的时候学长让我玩玩 github+hexo 搭建博客系统，那会还什么都不懂，连 github 对我来说也是个新鲜玩意，然后各种搜网上的教程搭建，拆了又搭，搭了发现显示有问题又拆，最后终于把一个蹩脚的网站搭好了，虽然颜值非常丑但至少还是有些成就感的。</li><li>后来因为大一也没啥专业课，唯一需要码代码的课是C语言和实验，所以技术没怎么长进，自然也养不成写博客的习惯。然后人生搭的第一个博客系统就这样荒废了。</li><li>再回首现在已经是大三老人了，这几年终于对计算机建立起了一个比较全面一点的认识，遇到各种问题和各种bug也知道该从哪里找，该怎么调试，挺感慨的。</li><li>从现在开始可以有空发一些文章到网上，一个是加深自己的对知识的理解，一个是可以把自己的学习经历记录下来，等到过几年再回头看，哦，我原来已经走了这么远。</li><li>个人而言未来无论是考研还是工作，努力提高自己的硬实力和软实力，才能在职业上走得长远，一张文凭只是个敲门砖，敲不出代码，学不懂技术，不会为人处世，不会有效沟通，一切都是空谈。</li></ul>]]></content>
      
      
      <categories>
          
          <category> deploy problem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
