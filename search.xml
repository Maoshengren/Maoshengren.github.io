<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>虚拟存储器</title>
      <link href="/2021/10/28/xu-ni-cun-chu-qi/"/>
      <url>/2021/10/28/xu-ni-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="1-物理和虚拟寻址"><a href="#1-物理和虚拟寻址" class="headerlink" title="1.物理和虚拟寻址"></a>1.物理和虚拟寻址</h3><blockquote><p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址</strong>。</p><p>CPU访问内存的最自然的方式就是使用物理地址。这种方式称为<strong>物理寻址</strong>。</p></blockquote><p><img src="/2021/10/28/xu-ni-cun-chu-qi/image-20211028094010419.png" style="zoom:50%;"></p><ul><li><p>提供给程序员的内存模型仅仅是物理内存，一组从0到某个最大值的地址，每个地址通常对应一个字节单元。</p></li><li><p>在这种情况下，内存中不可能同时有两个正在运行的程序。如果第一个程序写了一个新值到比如<code>addr 2000</code>，这将擦除第二个程序存储在那里的值。</p></li></ul><p>示例：</p><blockquote><p>有两个程序，每个程序的大小为16 KB。前者为阴影区域。</p></blockquote><ul><li>第一个程序从<code>addr 24</code>开始，<code>addr 24</code>包含一个<code>MOV</code>指令。</li><li>第二个程序从<code>addr 28</code>开始，<code>addr 28</code>包含一个<code>CMP</code>指令。</li><li>当两个程序从地址0开始在内存中连续加载时，有图(c)的情况。</li><li>在第一个程序运行后，操作系统可能决定运行第二个程序，该程序已加载在第一个程序之上，<code>addr 16384</code>。执行的第一个指令是<code>jmp 28</code>，它跳转到在第一个程序中的<code>ADD</code>指令，而不是它应该跳转到的<code>CMP</code>指令。</li></ul><blockquote><p>核心问题是这两个程序都引用<strong>绝对物理内存</strong>。 </p></blockquote><p><img src="/2021/10/28/xu-ni-cun-chu-qi/image-20211028095123548.png" style="zoom:50%;"></p><hr><blockquote><p>现代处理器一般使用<strong>虚拟寻址</strong>。</p><p>CPU通过生成一个<strong>虛拟地址</strong>(Virtual Address，VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的<strong>物理地址</strong>。</p><p>将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>(address translation)。</p><p>CPU芯片上叫做<strong>内存管理单元</strong>(Memory Management Unit, MMU)的专用硬件，利用存放在主存中的<strong>查询表</strong>来动态翻译虚拟地址，该表的内容由操作系统管理。</p></blockquote><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h3><blockquote><p>虚拟存储器通过在主存和辅存之间增加部分软件和硬件，使主存和辅存构成整体，如同大容量主存一样。</p><p>利用虚拟存储器提供的虚拟地址进行编程，在主存空间不增加的情况下不受主存空间的限制。</p></blockquote><ul><li>虚拟存储器充分利用程序局部性，采用按需加载方式。<ul><li>不直接将程序和代码载入主存，仅在相应的<strong>虚拟地址转换表</strong>登记虚拟地址对应<strong>磁盘地址</strong>。</li><li>程序执行并访问对应虚拟地址时，产生<strong>缺页异常</strong>，由操作系统从磁盘调入数据块。</li><li>程序仅加载一小部分空间即可运行，提高主存利用率。</li></ul></li></ul><p><strong>地址空间</strong></p><blockquote><p>虚拟存储器有三种地址空间：</p><p>虚拟地址空间：程序员用来编写程序的空间，虚地址</p><p>主存地址空间：物理地址空间，或叫实地址空间，实地址</p><p>辅存地址空间：磁盘的地址空间，辅存地址</p></blockquote><hr><h3 id="3-页式虚拟存储器"><a href="#3-页式虚拟存储器" class="headerlink" title="3.页式虚拟存储器"></a>3.页式虚拟存储器</h3><blockquote><p>以页（Page）为逻辑划分信息传送单位。</p></blockquote><p><strong>虚拟地址划分</strong></p><blockquote><p>虚拟地址被划分为<strong>虚拟页号</strong>（Virtual Page Number，VPN）和<strong>虚拟页偏移</strong>（Virtual Page Offset，VPO），物理地址也被划分为<strong>物理页号</strong>和<strong>物理页偏移</strong>。</p></blockquote><p><strong>页表</strong></p><blockquote><p>页表是一张保存虚拟页号VPN和物理页号PPN对应关系的查找表。</p><p>VPN作为索引进行访问，每个表项包括有效位、物理页号、修改位等。</p></blockquote><p><img src="/2021/10/28/xu-ni-cun-chu-qi/image-20211028103256423.png" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
            <tag> 虚拟存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IP层</title>
      <link href="/2021/10/27/wang-luo-ip-ceng/"/>
      <url>/2021/10/27/wang-luo-ip-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="网络IP层"><a href="#网络IP层" class="headerlink" title="网络IP层"></a>网络IP层</h2><h3 id="1-数据层面"><a href="#1-数据层面" class="headerlink" title="1.数据层面"></a>1.数据层面</h3><h4 id="1-1-网络层概述"><a href="#1-1-网络层概述" class="headerlink" title="1.1 网络层概述"></a>1.1 网络层概述</h4><blockquote><p>网络层的作用从表面上看极为简单，即将分组从一台发送主机移动到一台接收主机。为此，需要使用两种重要的网络层功能: </p></blockquote><ul><li><strong>转发</strong>。当一个分组到达某路由器的一条输人链路时，该路由器必须将该分组移动到适当的输出链路。转发是在<strong>数据平面</strong>中实现的<strong>唯一功能</strong>。</li><li><strong>路由选择</strong>。当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法(routing algorithm)。<strong>路由选择</strong>在网络层的<strong>控制平面</strong>中实现。</li></ul><blockquote><p>更为精确的描述：</p><p><strong>转发</strong>是指将分组从一个输入链路接口转移到适当的输出链路接口的<strong>路由器本地</strong>操作。时间尺度短：ns级别</p><p><strong>路由选择</strong>是指确定分组从源目的地所采取的端到端路径的网络范围处理过程。时间尺度长：s级别</p></blockquote><ul><li>每台网络路由器中有一个关键元素是它的<strong>转发表(forwardingtable)</strong>。路由器检查到达分组首部字段值，使用这些值在其转发表中搜索，转发分组。</li><li>这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的<strong>输出链路接口</strong>。</li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027141029742.png" style="zoom: 40%;"></p><p><strong>控制平面</strong></p><blockquote><p>路由选择算法决定了插入该转发表的内容。路由选择算法运行在每台路由器中，并且每台路由器都有转发和路由选择两种功能。</p></blockquote><p><strong>网络服务模型</strong></p><blockquote><p>网络服务模型定义了分组在发送和接收端系统之间的端到端运输特性。</p></blockquote><ul><li><strong>确保交付：</strong>确保分组最终到达目的地</li><li><strong>具有时延上界的确保交付：</strong>在特定的主机到主机时延上界内（100ms内 e.g.）交付</li><li><strong>有序分组交付</strong>：确保分组以发送顺序到达目的地</li><li><strong>确保最小带宽：</strong>在双方之间模拟一条特定比特速率的传输链路，只要发送方传输速率低于该速率，所有分组确保交付到目的主机</li><li><strong>安全性：</strong>在发送方加密数据报，在接收方解密数据报。</li></ul><p>因特网的网络层提供了单一的服务，称为<strong>尽力而为服务</strong>( best- effort service)。使用尽力而为服务，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付;既不能保证端到端时延，也不能保证有最小的带宽。</p><hr><h4 id="1-2-路由器工作原理"><a href="#1-2-路由器工作原理" class="headerlink" title="1.2 路由器工作原理"></a>1.2 路由器工作原理</h4><blockquote><p>下图显示了路由器的总体视图。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027142710900.png" style="zoom:40%;"></p><ul><li><strong>输入端口</strong><ul><li>执行物理层功能，在路由器上终止传入的物理链路。</li><li>与位于输入链路远端的数据链路层交互来执行数据链路层功能。</li><li>在输入端口执行查找功能，通过转发表决定路由器的输出端口。</li></ul></li><li><strong>交换结构</strong><ul><li>交换结构将路由器的输入端口连接到它的输出端口。这种交换结构完全<br>包含在路由器之中，即是一个网络路由器中的网络。</li></ul></li><li><strong>输出端口</strong><ul><li>输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。</li><li>当一条链路是双向的时(即承载两个方向的流量)，输出端口通常与该链路的输入端口成对出现在同一线路卡上。</li></ul></li><li><strong>路由选择处理器</strong>：<ul><li>路由选择处理器执行控制平面功能。</li><li>在传统的路由器中，它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。</li><li>在SDN路由器中，路由选择处理器负责与远程控制器通信，接收由远程控制器计算的转发表项并安装在输入端口。</li></ul></li></ul><hr><p><strong>输入端口处理和基于目的地转发</strong></p><blockquote><p>路由器用分组目的地址的前缀(prefix)与该表中的表项进行匹配;如果存在一个匹配项，则路由器向与该匹配项相关联的链路转发分组。</p><p>当有多个匹配时，路由器使用最长前缀匹配规则，即在表中寻找最长的匹配项。</p></blockquote><ul><li>通过查找确定了某分组的输出端口，则该分组就能够发送进人交换结构。</li><li>如果来自其他输入端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时被暂时阻塞。因此，一个被阻塞的分组必须要在输人端口处排队，并等待稍后被及时调度以通过交换结构。</li></ul><p>输入端口还需完成其他动作：</p><ol><li>必须出现物理层和链路层处理</li><li>必须检查分组的版本号、检验和以及寿命字段，并且重写后两个字段;</li><li>必须更新用于网络管理的计数器(如接收到的IP数据报的数目)。</li></ol><hr><p><strong>交换</strong></p><blockquote><p>交换结构位于一台路由器的核心部位，通过交换结构，分组能实际地从一个输入端口交换( 即转发)到一个输出端口中。交换可以用许多方式完成。</p></blockquote><ul><li><strong>经内存交换</strong>。在输入端口与输出端口之间的交换是在CPU (路由选择处理器)的直接控制下完成的。输入与输出端口的功能就像在传统操作系统中的I/O设备一样。<ul><li>分组到达输入端口时，通过中断被路由选择器复制进（<strong>读</strong>）内存。</li><li>从首部提取目的地址，在转发表中找出输出端口，将该分组复制到（<strong>写</strong>）输出端口的缓存。</li><li>如果内存带宽为每秒读写B个分组，则总的转发吞吐量(分组从输入端口被传送到输出端口的总速率，即一次<strong>读</strong>和一次<strong>写</strong>)必然小于B/2。</li></ul></li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027145001684.png" style="zoom:40%;"></p><ul><li><p><strong>经总线交换</strong>。输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。</p><ul><li>输入端口为分组预先计划一个标签，指示输出端口，分组传送到所有输出端口，但只有与<strong>该标签匹配的端口</strong>才能保存该分组。</li><li>然后标签在输出端口被去除，因为其仅用于交换机内部来跨越总线。</li><li>如果多个不同输出端口分组同时到达路由器，一次只有一个分组能够跨越总线。</li><li>每个分组必须跨过单一总线，故路由器的交换带宽受总线速率的限制。</li></ul></li><li><p><strong>经互联网络交换</strong>。一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口。每条垂直的总线与每条水平的总线交叉，交叉点通过交换结构控制器能开启和闭合。</p><ul><li>分组到达端口A，需要转发到端口Y时，交换机控制器闭合总线A和Y交叉部位的交叉点。</li><li>来自端口B的一个分组在同一时间能够转发到端口X，因为A到Y和B到X的分组使用不同的输入和输出总线。</li><li>纵横式交换机是非阻塞的(non-blocking)，即只要没有其他分组当前被转发到该输出端口，分组将不会被其他分组阻塞。如果目的地为相同的输出端口，则一个分组必须在输入端等待。</li></ul></li></ul><hr><p><strong>输出端口处理</strong></p><blockquote><p>输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027150908497.png" style="zoom:50%;"></p><hr><p><strong>排队</strong></p><blockquote><p>排队的位置和程度(在输入端口或者在输出端口排队)将取决于流量负载、交换结构的相对速率和线路速率。因为随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现<strong>丢包</strong>(packet loss)。</p></blockquote><p><strong>1.输入排队</strong><br>如果交换结构不能快得使所有到达分组无时延地通过它传送，在输入端口将出现分组排队，到达的分组必须加入输入端口队列中，以等待通过交换结构传送到输出端口。</p><p>假定该交换结构决定发送左上角队列前端的分组。在这种情况下，左下角队列中的深色阴影分组必须等待。但不仅该分组要等待，左下角队列中排在该分组后面的浅色阴影分组也要等待，即使右中侧输出端口(浅色阴影分组的目的地)中无竞争。</p><p>这种现象叫作输入排队交换机中的<strong>线路前部(Head-Of-the-Line HOL)阻塞</strong></p><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027151943793.png" style="zoom:50%;"></p><p><strong>2.输出排队</strong></p><ul><li>在时刻t，每个输入端口都到达了一个分组，每个分组都是发往最上侧的输出端口。</li><li>假定线路速度相同，交换机以3倍于线路速度的速度运行，一个时间单位以后，所有三个初始分组都被传送到输出端口,并排队等待传输。</li><li>在下一个时间单位中，这三个分组中的一个将通过输出链路发送出去。</li><li>之后又有两个新分组已到达交换机的入端；这些分组之一要发往最上侧的输出端口。</li><li>输出端口的<strong>分组调度</strong>( packet scheduler) 在这些排队分组中选择一个分组来传输</li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153011499.png" style="zoom:40%;"></p><hr><p><strong>分组调度</strong></p><p><strong>1.先进先出(FIFO)</strong></p><blockquote><p>FIFO(也称为先来先服务)调度规则按照分组到达输出链路队列的相同次序来选择分组在链路上传输。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153557356.png" style="zoom:50%;"></p><p><strong>2.优先权排队</strong></p><blockquote><p>到达输出链路的分组被分类放入输出队列中的<strong>优先权类</strong>，如图所示。</p><p>在同一优先权类的分组之间通常以FIFO方式完成。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153617049.png" style="zoom:50%;"></p><p><strong>3.循环和加权公平排队</strong></p><blockquote><p>在循环排队规则(round robin queuing discipline) 下，分组像使用优先权排队那样被分类。然而，在类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。</p><p>一个所谓的保持工作排队(work-conserving queuing)规则在有分组排队等待传输时，不允许链路保持空闲。当类中没有分组时，将立即检查循环序列中的下一个类。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027153859087.png" style="zoom:50%;"></p><hr><h4 id="1-3-网际协议-IPV4、寻址、IPV6"><a href="#1-3-网际协议-IPV4、寻址、IPV6" class="headerlink" title="1.3 网际协议 IPV4、寻址、IPV6"></a>1.3 网际协议 IPV4、寻址、IPV6</h4><p><strong>IPV4数据报格式</strong></p><blockquote><p>网络层分组被称为<strong>数据报</strong>。</p><p>一个IP数据报有20 byte的首部（不包含选项），若数据报承载了一个TCP报文段（20 byte首部），则每个数据报共有40 byte的首部。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027154105483.png" style="zoom: 50%;"></p><hr><p><strong>IPV4数据报分片</strong></p><blockquote><p>不是所有链路层协议都能承载相同长度的网络层分组。以太网帧能够承载不超过1500字节的数据，而某些广域网链路的帧可承载不超过576字节的数据。</p><p>一个链路层帧能承载的最大数据量叫作<strong>最大传送单元</strong>(Maximum Transmission Unit, <strong>MTU</strong>) </p><p>因为每个IP数据报封装在链路层帧在路由器间传输，故链路层协议的MTU严格地限制着IP数据报的长度。</p></blockquote><ul><li><p><strong>片</strong>在其到达目的地运输层以前需要重新组装。为坚持网络内核保持简单的原则，IPv4的设计者决定将数据报的重新组装工作放到端系统中，而不是放到网络路由器中。</p></li><li><p>为了让目的主机执行这些重新组装任务，IPv4的设计者将<strong>标识</strong>、<strong>标志</strong>和<strong>片偏移</strong>字段放在IP数据报首部中。</p><ul><li>当生成一个数据报时，发送主机在为该数据报贴上<strong>标识号</strong>。发送主机通常将它发送的每个数据报的标识号+1。</li><li>当某路由器需要对一个数据报分片时，形成的每个数据报具有<strong>初始数据报标识号</strong>。</li><li>当从同一发送主机收到一系列数据报时，检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。</li><li>为了让目的主机绝对地相信它已收到了初始数据报的最后一个片，最后一个片的<strong>标志</strong>比特被设为<strong>0</strong>，而所有其他片的<strong>标志</strong>比特被设为<strong>1</strong>。</li><li><strong>片偏移字段</strong>指定该片在初始IP数据报的位置。</li></ul></li></ul><hr><p><strong>IPV4编址</strong></p><blockquote><p>主机与物理链路之间的边界叫做<strong>接口</strong>。IP要求每台主机和路由器<strong>接口</strong>拥有自己的<strong>IP地址</strong>以发送和接收IP数据报。因此，从技术上讲，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p><p>为便于书写，IPV4地址采用点分十进制记法，如<code>127.0.0.1</code>。</p><p><code>223.1.1.0/24</code> 其中 <code>/24</code> 称为<strong>子网掩码</strong>，表示最左侧24位定义了子网地址。</p><p><strong>子网</strong>：分开主机和路由器的接口，使用接口端接入这些隔离网络的端点，每个隔离网络都叫做子网。</p></blockquote><p>因特网地址分配策略：<strong>无类别域间路由选择（Classless Interdomain Routing CIDR）</strong>。</p><ul><li>使用子网寻址，IP地址分为两部分，<code>a.b.c.d/x</code>，<code>x</code> 指示了地址的第一部分bits，一般称为地址的<strong>前缀</strong>。</li><li>一个组织通常被分配一块连续的地址，即有相同前缀。</li></ul><blockquote><p><strong>广播地址</strong>：<code>255.255.255.255</code>。目的地为该地址的报文段会被转发给同一网络所有主机。</p></blockquote><hr><p><strong>DHCP</strong></p><blockquote><p>动态主机配置协议（Dynamic Host Configuration)，允许主机自动获取一个IP地址。同时获得子网掩码、第一跳路由器地址（默认网关）、本地DNS服务器地址等。</p></blockquote><ul><li>如下图，在本机使用<code>ipconfig</code>命令即可查看网络配置。</li></ul><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027193318662.png" style="zoom: 67%;"></p><p>对于一个新到达的主机，DHCP协议分为四步分配地址：</p><p><strong>1.DHCP服务器发现</strong></p><ul><li>通过使用DHCP发现报文实现。客户端在UDP分组中向端口67发送该报文。UDP分组封装在IP数据报中，使用广播目的地址<code>255.255.255.255</code>，将IP数据报传递给链路层，然后广播到子网连接的节点。</li></ul><p><strong>2.DHCP服务器提供</strong></p><ul><li>DHCP服务器收到DHCP发现报文，用<strong>DHCP提供报文</strong>响应客户端。仍用<code>255.255.255.255</code>向子网所有节点广播。</li><li>子网可能存在多个DHCP服务器，因此服务器报文中包含发现报文的<strong>事务ID</strong>、推荐给客户端的<strong>IP地址</strong>、<strong>网络掩码</strong>、IP地址<strong>租用期</strong>（IP地址有效时间，一般为几小时-几天）。</li></ul><p><strong>3.DHCP请求</strong></p><ul><li>客户端从一个或多个服务器提供中选择一个，并向选中的服务器提供<strong>DHCP请求报文</strong>，回显配置的参数。</li></ul><p><strong>4.DHCP ACK</strong></p><ul><li>服务器用<strong>DHCP ACK报文</strong>对DHCP请求进行响应，证实所求参数。</li></ul><p>客户端收到<strong>ACK</strong>后，交互完成。</p><hr><p><strong>网络地址转换</strong></p><blockquote><p>地址空间<code>10.0.0.0/8</code>是在[RFC 1918]中保留的三部分IP地址空间之一，这些地址用于下图等<strong>专用网络</strong>或具有专用地址的地域。</p><p><strong>具有专用地址的地域</strong>是指其地址仅对该网络中的设备有意义的网络。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027194912842.png" alt=""></p><ul><li><p>NAT使能路由器对于外部世界来说行为就如同具有单一IP地址的单一设备。</p><ul><li>上图所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址<code>138.76.29.7</code>,且所有进入家庭的报文都拥有同一个目的IP地址<code>138.76.29.7</code>。</li><li>NAT使能路由器对外界隐藏了家庭网络的细节。</li></ul></li><li><p>通过<strong>NAT转换表</strong>(NAT translation table)，路由器知道将分组转发给哪个内部主机。</p></li></ul><hr><p><strong>IPV6</strong></p><blockquote><p>IPV6数据报格式入下图。</p></blockquote><p><img src="/2021/10/27/wang-luo-ip-ceng/image-20211027195610223.png" alt=""></p><ul><li><strong>扩大的地址容量：</strong>128bits。</li><li><strong>40字节定长首部：</strong>允许路由器更快地处理数据。</li><li><strong>流标签：</strong>流（flow）。该字段用于“给属于特殊流（发送方要求特殊处理）的分组加上标签”。</li><li><strong>下一个首部(Next hdr)：</strong>标识数据报中内容需要交付给哪个协议（如TCP或UDP）。</li><li><strong>跳限制(Hop limit)：</strong>转发数据报的每台路由器将该字段-1。如果计数为0，则丢弃。</li></ul><hr><h3 id="2-控制平面"><a href="#2-控制平面" class="headerlink" title="2.控制平面"></a>2.控制平面</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File I/O</title>
      <link href="/2021/10/26/file-io/"/>
      <url>/2021/10/26/file-io/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cache工作原理</title>
      <link href="/2021/10/26/cache-gong-zuo-yuan-li/"/>
      <url>/2021/10/26/cache-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h2><h3 id="1-Cache基本概念"><a href="#1-Cache基本概念" class="headerlink" title="1. Cache基本概念"></a>1. Cache基本概念</h3><blockquote><p>为提升CPU访问主存的性能，通常会在CPU和主存之间增加一个隐藏的小容量快速<code>SRAM</code>，称为 <code>cache</code>。将主存中经常访问或即将访问的数据的副本调度到小容量的 <code>SRAM</code> 中，使得大部分数据访问都可以在其中进行，从而提升性能。</p></blockquote><ul><li>CPU通过字节地址访问快速的 <code>cache</code>，通过一定查找机制判断数据是否在 <code>cache</code> 中<ul><li>如果数据在 <code>cache</code> 中，则称为<strong>数据命中（cache hit）</strong>，<strong>命中访问时间</strong>为 $t_c$，包括查找时间和 <code>cache</code> 访问时间</li><li>如果数据不在 <code>cache</code> 中，则称为<strong>数据丢失（cache miss）</strong>，需要将缺失的数据从主存调入 <code>cache</code> 中；数据缺失的访问时间称为<strong>缺失补偿（miss penalty）</strong>，包括数据查找时间、主存访问时间、<code>cache</code> 访问时间，通常用主存访问时间 $t_m$ 表示。</li></ul></li><li>为了便于比较和快速查找，<code>cache</code> 和主存都被分成若干个固定大小的<strong>块</strong>，每个块包含若干<strong>字</strong>，数据缺失时将<strong>数据所在块</strong>载入 <code>cache</code> 中 [这种预读策略可以充分利用空间局部性，提高顺序访问的命中概率]。<ul><li>块过小无法使<strong>预读策略</strong>优化<a href="#2. 程序局部性">空间局部性</a>，块过大使<strong>替换算法</strong>无法利用<a href="#2. 程序局部性">时间局部性</a>。</li></ul></li><li>数据分块后，地址可以分为<strong>块地址</strong>和<strong>偏移地址</strong>， <code>cache</code> 容量较小，因此主存地址字段长度大于 <code>cache</code> 地址字段长度。</li></ul><p><strong>命中率</strong>（评价 <code>cache</code> 性能）</p><ul><li><p>设 $N_c$ 为运行期间命中 <code>cache</code> 次数，$N_m$ 为从主存访问次数，命中率 $h$ 为：</p><script type="math/tex; mode=display">h = \frac{N_c}{N_c+N_m}, \;\;h\rightarrow1,\;性能越好</script><p>$1-h$ 称为<strong>缺失率</strong>。</p></li><li><p>$t_c$ 表示命中访问时间，$t_m$ 表示缺失访问时间，平均访问时间 $t_a$ 为</p><script type="math/tex; mode=display">t_a=ht_c+(1-h)t_m,\;\;cache 目的是使t_a\rightarrow t_c</script><p> $e=t_c/t_a$ 为<strong>访问效率</strong>，$r=t_m/t_c$ 为主存相对 <code>caceh</code> 访问时间的倍数，</p><script type="math/tex; mode=display">e=\frac{t_c}{t_a}=\frac{1}{h+(1-h)r}</script><p>显然访问效率 $e $ 与 $r$ 和 $h$ 中有关。</p></li></ul><hr><h3 id="2-程序局部性"><a href="#2-程序局部性" class="headerlink" title="2. 程序局部性"></a>2. 程序局部性</h3><blockquote><p><strong>时间局部性</strong>：当程序访问一个存储位置时，该位置在未来可能会被多次访问。比如程序的循环结构和调用过程。</p><p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，则其附近的存储单元也即将被访问。如指令代码、数组、结构体等顺序存放的结构。</p></blockquote><hr><h3 id="3-Cache-读写流程"><a href="#3-Cache-读写流程" class="headerlink" title="3.  Cache 读写流程"></a>3.  <code>Cache</code> 读写流程</h3><p><code>Cache</code> 读流程较为简单，略过。</p><p><code>Cache</code> 写流程：</p><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026151655241.png" style="zoom:67%;"></p><p>数据缺失时有两种不同策略：</p><ul><li>若为<strong><a href="#6. 写入策略">写分配法</a></strong>，则需将 <code>WA</code> 对应的数据块载入 <code>Cache</code> 中，再进行写命中相同流程。</li><li>若不为写分配法，则将数据写入主存即返回。</li></ul><p>新写入 <code>Cache</code> 的数据域主存数据不一致，称为<strong>脏数据</strong>。</p><p>数据写入完成后：</p><ul><li>若为<strong>写回策略</strong>，则写入操作结束，这种方式响应最快，但会产生不一致性。</li><li>若为<strong>写穿策略</strong>，则需将脏数据写入主存后返回，响应速度慢，但不会产生不一致性。</li></ul><p><code>Cache</code> 实现的关键技术</p><ol><li>数据查找：快速判断数据是否在 <code>Cache</code> 中</li><li>地址映射：主存数据块如何放置到 <code>Cache</code> 中</li><li>替换策略： <code>Cache</code> 满后如何替换数据块</li><li>写入策略：如何保证 <code>Cache</code> 与主存一致性</li></ol><hr><h3 id="4-地址映射"><a href="#4-地址映射" class="headerlink" title="4. 地址映射"></a>4. 地址映射</h3><blockquote><p>将主存地址空间映射到 <code>Cache</code> 地址空间，即载入 <code>Cache</code> 块的规则。</p><ul><li><strong>全相联</strong>：主存块可以映射到 <code>Cache</code> 任意数据块</li><li><strong>直接相联</strong>：主存块只能映射到 <code>Cache</code> 中固定块</li><li><strong>组相联</strong>：主存块只能映射到 <code>Cache</code> 固定组中的任意块</li></ul></blockquote><h4 id="4-1-全相联映射"><a href="#4-1-全相联映射" class="headerlink" title="4.1 全相联映射"></a>4.1 全相联映射</h4><blockquote><p>新的主存块可以载入 <code>Cache</code> 中任何一个空位置，只有 <code>Cache</code> 满时才进行数据块置换。</p><p> <code>Cache</code> 利用率最高，查找成本较高，CAM提供查找功能。</p></blockquote><ul><li>由于主存块可以放置在任意块中，为方便查找，需记录 有效位、主存块地址标记、脏数据标志位、淘汰计数等。</li><li>通常将一个 <code>Cache</code> 数据块和标志信息一起称为一个 <code>Cache</code>行/槽，有多少 <code>Cache</code> 数据块对应有多少 <code>Cache</code> 行。</li></ul><blockquote><p>主存地址划分为块地址(<strong>tag</strong>)和块内偏移地址(<strong>offset</strong>)两部分，长度分别为 $s,w$， <code>Cache</code> 块大小为 $2^w$ 字节， <code>Cache</code> 缓冲区容量为 $n\times 2^w$ 字节，只考虑有效位和主存块地址， <code>Cache</code> 实际容量为 $n\times (1+s+8\times 2^w)$，主存容量为 $2^{s+w}$ 字节。</p></blockquote><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026154708162.png" style="zoom:67%;"></p><p>全相联映射访问过程：主存 <code>tag</code> 字段将与所以行中 <code>tag</code> 字段进行比较</p><ul><li><code>valid</code> 有效位必须设置为1</li><li><code>tag</code> 必须与主存 <code>tag</code> 匹配</li><li>3位 <code>offset</code> 决定选中哪一个字</li></ul><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026155124123.png" alt=""></p><blockquote><p>全相联映射方式特点：</p><ul><li>主存块映射到  <code>Cache</code> 任意一行， <code>Cache</code> 利用率高</li><li><code>Cache</code> 有空行就可以插入， <code>Cache</code> 冲突率低</li><li>查找需要并发查找每一行，硬件成本高，只适合小容量 <code>Cache</code> </li><li><code>Cache</code> 满时需进行替换，替换算法复杂</li></ul></blockquote><hr><h4 id="4-2-直接相联映射"><a href="#4-2-直接相联映射" class="headerlink" title="4.2 直接相联映射"></a>4.2 直接相联映射</h4><blockquote><p>每一个主存地址只能映射到 <code>Cache</code> 固定行，映射规则为：</p><p>$cache 行号\;i=主存块号\; j\mod(cache 行数 \;n)$ </p><p>等效于将<strong>主存块</strong>分为与 <code>Cache</code> 行数相同的分区，因此主存地址分为：区地址 [<code>tag</code>]，区内行索引 [<code>index</code>]，块内偏移地址 [<code>offset</code>]。</p></blockquote><p>直接相联映射访问过程：</p><ul><li><code>index</code> 字段选中对应的 <code>Cache</code> 行 </li><li><code>valid</code> 有效位必须设置为1</li><li><code>tag</code> 必须与主存 <code>tag</code> 匹配</li><li>3位 <code>offset</code> 决定选中哪一个字</li></ul><blockquote><p>直接相联映射的特点：</p><ul><li>主存块只能映射到  <code>Cache</code> 中固定行， <code>Cache</code> 利用率低，命中率低</li><li><code>index</code> 相同的主存块映射 <code>Cache</code> 同一行， <code>Cache</code> 冲突率高 [小声bb：冲突率高不就是利用率低吗，跟第一条差不多]</li><li>查找只需与对应行的标记字段 <code>tag</code> 进行比较，硬件成本低</li><li>无须使用复杂替换算法</li></ul></blockquote><hr><h4 id="4-3-组相联映射"><a href="#4-3-组相联映射" class="headerlink" title="4.3 组相联映射"></a>4.3 组相联映射</h4><blockquote><p> <code>Cache</code> 分成固定大小的组，每组有 $k$ 行，称为 $k-$路组相联，主存数据先采用<strong>直接相联映射</strong>定位到 <code>Cache</code> 固定的组，再采用<strong>全相联映射</strong>到组内任意 <code>Cache</code> 行。组相联映射规则：</p><p>$cache \; 组号=主存块号\mod (cache组数)$ </p></blockquote><p> <code>Cache</code> 模型：</p><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026160747150.png" style="zoom:67%;"></p><p> 组相联<code>Cache</code>映射方式： </p><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026160910295.png" style="zoom:67%;"></p><p>组相联映射访问过程：</p><ul><li><code>index</code> 字段选中对应的 <code>Cache</code> 行 <ul><li>组中的任何一行都可以包含映射到这个组的任何内存块。 因此缓存必须搜索组中的每一行，搜索其标记与地址中的标记匹配的有效行。 如果缓存找到这样的一行，那么就有一个 hit。</li></ul></li><li><code>valid</code> 有效位必须设置为1</li><li><code>tag</code> 必须与主存 <code>tag</code> 匹配</li><li>3位 <code>offset</code> 决定选中哪一个字</li></ul><p><img src="/2021/10/26/cache-gong-zuo-yuan-li/image-20211026161308510.png" alt=""></p><blockquote><p>组相联映射的特点：</p><ul><li>每一组多路比较器大幅减少，为各 <code>Cache</code> 共享，硬件成本更低</li><li>每组只有一个 <code>Cache</code> 行时，变成直接相联映射</li><li>整个 <code>Cache</code> 只有一组时，变成全相联映射</li></ul></blockquote><hr><h3 id="5-替换算法"><a href="#5-替换算法" class="headerlink" title="5. 替换算法"></a>5. 替换算法</h3><blockquote><p>替换算法与 <code>Cache</code> 组织方式相关：</p><p>直接相联映射不需要替换算法，因为一个主存块只能存放在一个特定行；</p><p>全相联映射执行替换算法时涉及所有行；</p><p>组相联映射执行替换算法设计特定组的所有行。</p></blockquote><h4 id="5-1-FIFO算法"><a href="#5-1-FIFO算法" class="headerlink" title="5.1 FIFO算法"></a>5.1 FIFO算法</h4><blockquote><p><strong>先进先出算法</strong>按照数据块进入 <code>Cache</code> 先后决定替换顺序，需要替换时，最先被载入的 <code>Cache</code> 行被替换。</p><p>需记录每个 <code>Cache</code> 行载入 <code>Cache</code> 的时间戳</p><p>特点：</p><ul><li>系统开销较小，但不考虑程序访问的局部性，有可能导致 <code>Cache</code> 命中率低</li></ul></blockquote><h4 id="5-2-LFU算法"><a href="#5-2-LFU算法" class="headerlink" title="5.2 LFU算法"></a>5.2 LFU算法</h4><blockquote><p><strong>最不经常使用算法</strong>将访问次数最少的 <code>Cache</code> 行替换，每行需设置淘汰计数器，新载入 <code>Cache</code> 行为0，每命中一次计数器+1，替换时对所有可能替换行的计数值比较，<strong>计数值最小</strong>的替换。</p><p>特点：</p><ul><li>计数器统计 <code>Cache</code> 启动后至今的访问次数，不能反映近期访问情况。</li></ul></blockquote><h4 id="5-3-LRU算法"><a href="#5-3-LRU算法" class="headerlink" title="5.3 LRU算法"></a>5.3 LRU算法</h4><blockquote><p><strong>近期最少使用算法</strong>将近期最久未访问的 <code>Cache</code> 行进行替换。也需设置计数器， <code>Cache</code> 命中行计数器清0，其余行+1，替换时对所有可能替换行的计数值比较，<strong>计数值最大</strong>的替换。</p><p>特点：</p><ul><li>保护了刚载入 <code>Cache</code> 的新数据，符合<code>Cache</code> 工作原理，有较高命中率。</li><li>实现难点为比较多行计数器，2-路组相联 <code>Cache</code> 能大大简化情况。</li></ul></blockquote><h4 id="5-4-随机替换算法"><a href="#5-4-随机替换算法" class="headerlink" title="5.4 随机替换算法"></a>5.4 随机替换算法</h4><blockquote><p> <strong>随机替换算法</strong>对特定的行中随机选取一行进行替换。</p><p>特点：</p><ul><li>硬件实现最容易，速度快。</li><li>随意换出的数据可能即将访问，降低命中率。负面影响随着 <code>Cache</code> 增大而减小。</li></ul></blockquote><hr><h3 id="6-写入策略"><a href="#6-写入策略" class="headerlink" title="6. 写入策略"></a>6. 写入策略</h3><h4 id="写回法（Write-Back）"><a href="#写回法（Write-Back）" class="headerlink" title="写回法（Write-Back）"></a>写回法（Write-Back）</h4><blockquote><p>CPU对 <code>Cache</code> 写命中时，只修改 <code>Cache</code> 内容，不立即写入主存，只有此行被替换时才将脏数据写回主存。</p></blockquote><ul><li>这种策略使 <code>Cache</code> 在读写操作均起到高速缓存作用。</li><li>每个 <code>Cache</code> 行必须有一个修改位，即脏位（dirty bit），改写过则为1，未改写则为0</li><li>由于不一致性，DMA操作可能获得的是旧数据</li></ul><h4 id="写穿法（Write-Through）"><a href="#写穿法（Write-Through）" class="headerlink" title="写穿法（Write-Through）"></a>写穿法（Write-Through）</h4><blockquote><p>又称直写法， <code>Cache</code> 命中时，同时对 <code>Cache</code> 和主存中同一数据块进行修改。 <code>Cache</code> 无需脏位，替换时可直接替换。</p></blockquote><ul><li>在多核CPU下，每个核都有对应 <code>Cache</code> ，因此即使写穿法也无法保证 <code>Cache</code> 同步更新。</li></ul><hr><p>以上就是关于 <code>Cache</code> 的全部内容，若还有知识点再进行补充。</p><hr><p>参考：</p><p>计算机组成原理（微课版），大萝卜</p><p>CSAPP（3rd edition）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 线程模型</title>
      <link href="/2021/10/24/netty-xian-cheng-mo-xing/"/>
      <url>/2021/10/24/netty-xian-cheng-mo-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO</title>
      <link href="/2021/10/24/java-nio/"/>
      <url>/2021/10/24/java-nio/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><blockquote><p>首先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型: </p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Excutors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPollExecutor</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//线程池</span>    <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 主线程死循环等待新连接到来</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>currentThread<span class="token punctuation">.</span><span class="token function">isInturrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment">// 接受新的socket</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 为新的连接创建新的线程</span>        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConnectIOnHandler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConnectIOnHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">ConnectIOnHandler</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> socket<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 死循环处理读写事件</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>currentThread<span class="token punctuation">.</span><span class="token function">isInturrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>socket<span class="token punctuation">.</span><span class="token function">isClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 读取数据</span>            <span class="token class-name">String</span> someThing <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>someThing<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment">// 处理数据</span>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                    <span class="token comment">// 写数据</span>                    socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/10/24/java-nio/image-20211024112633666.png" alt="" style="zoom:50%;"></p><blockquote><p>这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于 <code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code>三个主要函数都是同步阻塞的，当一个连接在处理 I/O 的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里。</p><p>这也是为什么在做计网实验的时候单线程只能处理一次请求，如果再次发出请求服务器根本不会响应，因为服务器被阻塞在读写了。</p></blockquote><ul><li>多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单。</li></ul><p>这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：</p><ol><li>线程的创建和销毁成本很高</li><li>线程本身占用较大内存</li><li>线程的切换成本很高</li></ol><hr><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>传统的BIO里面 <code>socket.read()</code>，如果TCP <code>RecvBuffer</code> 里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP <code>RecvBuffer</code>有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。(解释地真地道)</p><blockquote><p>NIO<strong>只有在连接/通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，这就大大地减少了系统的开销。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">NIO的核心</th><th style="text-align:left">对应的类或接口</th><th style="text-align:left">应用</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">缓冲区</td><td style="text-align:left"><code>Buffer</code></td><td style="text-align:left">文件IO/网络IO</td><td style="text-align:left">存储数据</td></tr><tr><td style="text-align:left">通道</td><td style="text-align:left"><code>Channel</code></td><td style="text-align:left">文件IO/网络IO</td><td style="text-align:left">运输</td></tr><tr><td style="text-align:left">选择器</td><td style="text-align:left"><code>Selector</code></td><td style="text-align:left">网络IO</td><td style="text-align:left">控制器</td></tr></tbody></table></div><h3 id="单线程-Reactor"><a href="#单线程-Reactor" class="headerlink" title="单线程 Reactor"></a><strong>单线程 <code>Reactor</code></strong></h3><blockquote><p><code>Reactor</code> 模型中定义的三种角色：</p></blockquote><ul><li><code>Reactor</code> ：负责监听和分配事件，将I/O事件分派给对应的 <code>Handler</code>。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li><code>Acceptor</code>：处理客户端新连接，并分派请求到处理器链中。</li><li><code>Handler</code>：将自身与事件绑定，执行非阻塞读/写任务，完成 <code>channel</code> 的读入，完成处理业务逻辑后，负责将结果写出 <code>channel</code>。可用资源池来管理。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">ChannelHandler</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">channelReadable</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">channelWritable</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Channel</span><span class="token punctuation">{</span>    <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>    <span class="token class-name">Event</span> event<span class="token punctuation">;</span><span class="token comment">//读，写或者连接</span><span class="token punctuation">}</span><span class="token comment">//IO线程主循环:</span><span class="token keyword">class</span> <span class="token class-name">IoThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel<span class="token punctuation">;</span>        <span class="token comment">//选择就绪的事件和对应的连接</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>channel<span class="token operator">=</span><span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>accept<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果是新连接，则注册一个新的读写处理器</span>                <span class="token function">registerNewChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>write<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果可以写，则执行写事件</span>                <span class="token function">getChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channelWritable</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>read<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果可以读，则执行读事件</span>                <span class="token function">getChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channelReadable</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//所有channel的对应事件处理器</span>    <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Channel</span>，<span class="token class-name">ChannelHandler</span><span class="token operator">&gt;</span> handlerMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这也是最简单的 <code>Reactor</code> 模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。 </p><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p></blockquote><p><img src="/2021/10/24/java-nio/image-20211021165753294-16350547783021.png" alt="" style="zoom:40%;"></p><p><code>Reactor</code> 处理请求的流程：</p><ol><li><code>Reactor</code> 对象通过 <code>select</code> 监控连接事件，收到事件后通过 <code>dispatch</code> 进行转发。</li><li>如果是连接建立的事件，则由 <code>acceptor</code> 接受连接，并创建 <code>handler</code> 处理后续事件。</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用 <code>Handler</code> 来响应。</li><li><code>handler</code> 会完成 <code>read</code> <code>-&gt;</code> 业务处理 <code>-&gt;</code> <code>send</code> 的完整业务流程。</li></ol><blockquote><p><strong>单线程模式的缺点:</strong></p><ol><li>当其中某个 <code>handler</code> 阻塞时， 会导致其他所有的 client 的 <code>handler</code> 都得不到执行， 并且更严重的是， <code>handler</code> 的阻塞也会导致整个服务不能接收新的 client 请求(因为 <code>acceptor</code> 也被阻塞了)。</li></ol></blockquote><h3 id="多线程-Reactor"><a href="#多线程-Reactor" class="headerlink" title="多线程 Reactor"></a><strong>多线程 <code>Reactor</code></strong></h3><blockquote><p>连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。</p><p>在线程 <code>Reactor</code> 模式基础上，做如下改进：</p><p>（1）将 <code>Handler</code> 处理器的执行放入线程池，多线程进行业务处理。 </p><p>（2）而对于 <code>Reactor</code> 而言，可以仍为单个线程。如果服务器为多核的CPU，为充分利用系统资源，可以将 <code>Reactor</code> 拆分为两个线程。</p></blockquote><p><img src="/2021/10/24/java-nio/v2-22efc734724d07251f8293e2f1143639_720w.png" alt="" style="zoom: 67%;"></p><p>下图是 <code>netty in action</code> 中关于NIO的流程图。</p><p><img src="/2021/10/24/java-nio/image-20211022204547930.png" alt=""></p><p>多线程 <code>Reactor</code> 消息处理流程：</p><ol><li>从主线程池中随机选择一个 <code>Reactor</code> 线程作为 <code>acceptor</code> 线程，用于绑定监听端口，接收客户端连接</li><li><code>acceptor</code> 线程接收客户端连接请求之后创建新的 <code>SocketChannel</code>，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作</li><li>步骤2完成之后，业务层的链路正式建立，将 <code>SocketChannel</code> 从主线程池的 <code>Reactor</code> 线程的多路复用器上摘除，重新注册到Sub线程池的线程上，并创建一个 <code>Handler</code> 用于处理各种连接事件</li><li>当有新的事件发生时，<code>SubReactor</code> 会调用连接对应的 <code>Handler</code> 进行响应</li><li><code>Handler</code> 通过 <code>Read</code> 读取数据后，会分发给后面的 <code>Worker</code> 线程池进行业务处理</li><li><code>Worker</code> 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 <code>Handler</code> 进行处理</li><li><code>Handler</code> 收到响应结果后通过 <code>Send</code> 将响应结果返回给 <code>Client</code> </li></ol><p><img src="/2021/10/24/java-nio/image-20211024141840397.png" alt="" style="zoom:50%;"></p><blockquote><p><code>Reactor</code> 模式在 IO 读写数据时还是在同一个线程中实现的，即使使用多个 <code>Reactor</code> 机制的情况下，那些共享一个 <code>Reactor</code> 的 <code>Channel</code> 如果出现一个<strong>长时间的数据读写</strong>，会影响这个 <code>Reactor</code> 中其他<code>Channel</code> 的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的 <code>Thread-Per-Connection</code> 或许是一个更好的选择，或则此时使用改进版的<code>Reactor</code> 模式如 <code>Proactor</code> 模式。</p></blockquote><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a><code>Proactor</code></h3><blockquote><p><code>Reactor</code> 模型用于同步I/O，而 <code>Proactor</code> 模型运用于异步I/O操作。 </p></blockquote><p><strong>模型</strong></p><p><img src="/2021/10/24/java-nio/v2-35bd4bdf3b12246fb005415d3a29ecc0_r.jpg" alt=""></p><p><strong>模块关系</strong> </p><ol><li><code>Procator Initiator</code>负责创建<code>Procator</code>和<code>Handler</code>，并将<code>Procato</code>r和<code>Handler</code>都通过<code>Asynchronous operation processor</code>注册到内核。</li><li><code>Asynchronous operation processor</code>负责处理注册请求，并完成IO操作。完成IO操作后会通知<code>procator</code>。</li><li><code>procator</code>根据不同的事件类型回调不同的<code>handler</code>进行业务处理。<code>handler</code>完成业务处理，<code>handler</code>也可以注册新的<code>handler</code>到内核进程。</li></ol><p>消息处理流程：</p><p><strong>读取</strong>操作：</p><ol><li>应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。</li><li>事件分离器等待读取操作完成事件。</li><li>在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将数据读写到<strong>应用传递进来的缓冲区</strong>(如Netty中的<code>ByteBuf</code>)中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。</li><li>事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</li></ol><blockquote><p>异步IO都是操作系统负责将数据读写到<strong>应用传递进来的缓冲区</strong>供应用程序操作。</p></blockquote><p>Proactor中写入操作和读取操作，只不过感兴趣的事件是完成事件。</p><blockquote><p>在 Linux 下的异步 I/O 是不完善的， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p></blockquote><hr><h4 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h4><p>Netty采用的是<strong>主从线程模型</strong>。下面是Netty使用中很常见的一段代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">EventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">EventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token annotation punctuation">@Override</span>                 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpServerCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpObjectAggregator</span><span class="token punctuation">(</span><span class="token number">65536</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChunkedWriteHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpStaticFileServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">Channel</span> ch <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             ch<span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义了两个<code>EventLoopGroup</code>，其中<code>bossGroup</code>对应的就是主线程池，只接收客户端的连接（注册，初始化逻辑），具体的工作由<code>workerGroup</code>这个从线程池来完成。</li><li>客户端和服务器建立连接后，NIO会在两者之间建立<code>Channel</code>，所以启动类调用<code>channel</code>方法就是为了指定建立什么类型的通道。</li><li>启动类还调用了<code>handler()</code>和<code>childHandler()</code>方法，这两个方法中提及的<code>handler</code>是一个处理类的概念，他负责处理连接后的一个个<code>Channel</code>的相应处理。<code>handler()</code>指定的处理类是主线程池中对通道的处理类，<code>childHandler()</code>方法指定的是从线程池中对通道的处理类。<ul><li>Netty中，可以注册多个<code>handler</code>。<code>ChannelInboundHandler</code>按照注册的先后顺序执行；<code>ChannelOutboundHandler</code>按照注册的先后顺序逆序执行</li></ul></li></ul><blockquote><p>如果需要在客户端连接前的请求进行<code>handler</code>处理，则需要配置<code>handler()</code>；如果是处理客户端连接之后的<code>handler</code>，则需要配置在<code>childHandler()</code>。</p></blockquote><p><strong>Netty三大组件</strong></p><p><code>Channel</code>接口提供了一个API，大大降低了直接使用<code>Sockets</code>的复杂性。当创建<code>Channel</code>时，它会自动分配自己的<code>ChannelPipeline</code>。<code>ChannelPipeline</code>中含有一些<code>ChannelHandlers</code>，用于用户自定义处理事件。数据通过<code>Channel</code>在各个<code>Handler</code>之间流动。</p><p><img src="/2021/10/24/java-nio/image-20211024185955001.png" alt=""></p><p><code>EventLoop</code>定义了Netty的核心抽象，用于处理在连接生命周期内发生的事件。<code>Channel</code>在其生命周期内注册为一个<code>EventLoop</code>。一个<code>EventLoop</code>可以被分配给一个或多个<code>Channel</code>。</p><p>关系如下图所示：</p><p><img src="/2021/10/24/java-nio/image-20211024185355812.png" alt=""></p><p>Netty中的所有I/O操作都是<strong>异步</strong>的。因为一个操作可能不会立即返回，所以我们需要一种方法在以后确定它的结果。为此，Netty提供了<code>ChannelFuture</code>，其<code>addListener()</code>方法注册一个<code>ChannelFutureListener</code>，当<strong>操作完成时通知</strong>它(无论是否成功)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">channelFuture<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelProgressiveFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationProgressed</span><span class="token punctuation">(</span><span class="token class-name">ChannelProgressiveFuture</span> future<span class="token punctuation">,</span> <span class="token keyword">long</span> progress<span class="token punctuation">,</span> <span class="token keyword">long</span> total<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// total unknown</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer progress: "</span> <span class="token operator">+</span> progress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer progress: "</span> <span class="token operator">+</span> progress <span class="token operator">+</span> <span class="token string">" / "</span> <span class="token operator">+</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelProgressiveFuture</span> future<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer complete."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码就是通过添加 <code>FutureListener</code> 实现I/O操作完成后在Console中打印信息的功能。</p><hr><p>参考：</p><p>Netty In Action</p><p><a href="https://zhuanlan.zhihu.com/p/23488863">Java NIO浅析 - 知乎 (zhihu.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1573934">netty Reactor模式（源码死磕 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p><a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署问题</title>
      <link href="/2021/10/23/deploy-problem/"/>
      <url>/2021/10/23/deploy-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo部署到github上遇到的问题"><a href="#Hexo部署到github上遇到的问题" class="headerlink" title="Hexo部署到github上遇到的问题"></a>Hexo部署到github上遇到的问题</h2><ul><li>按照正常流程操作<ul><li>下载node，npm，git等工具</li><li>创建一个合法名字的github仓库</li><li>用 <code>npm install hexo -g</code> 安装hexo</li><li><code>hexo init + npm install</code> 初始化并安装必要组件</li><li><code>hexo g</code> 生成 <code>hexo s</code> 本地预览</li><li><code>hexo d</code> 部署到github上</li></ul></li></ul><p>然后就发现，github上根本不显示我上传的网页。大一那会还什么都不懂，调试了三天都还是错的，最后稀里糊涂地才能访问。<br>其实就是在 <code>_config.yml</code> 文件中：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">deploy:  type: git  repository: git@github.com:Maoshengren/Maoshengren.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不能用 <code>master</code> 分支，需要改成 <code>main</code>。 在github上检查发现文件都已经上传上去了，只是显示的问题，所以肯定是部署错误了，一个是配置中的 <code>url</code> 可能不对</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: http://Maoshengren.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个是我发现我所在的分支名称是 <code>main</code> 而不是<code>master</code>，将这些改好后再次访问我的网站就成功。</p><ul><li>大一刚入学的时候学长让我玩玩 github+hexo 搭建博客系统，那会还什么都不懂，连 github 对我来说也是个新鲜玩意，然后各种搜网上的教程搭建，拆了又搭，搭了发现显示有问题又拆，最后终于把一个蹩脚的网站搭好了，虽然颜值非常丑但至少还是有些成就感的。</li><li>后来因为大一也没啥专业课，唯一需要码代码的课是C语言和实验，所以技术没怎么长进，自然也养不成写博客的习惯。然后人生搭的第一个博客系统就这样荒废了。</li><li>再回首现在已经是大三老人了，这几年终于对计算机建立起了一个比较全面一点的认识，遇到各种问题和各种bug也知道该从哪里找，该怎么调试，挺感慨的。</li><li>从现在开始可以有空发一些文章到网上，一个是加深自己的对知识的理解，一个是可以把自己的学习经历记录下来，等到过几年再回头看，哦，我原来已经走了这么远。</li><li>个人而言未来无论是考研还是工作，努力提高自己的硬实力和软实力，才能在职业上走得长远，一张文凭只是个敲门砖，敲不出代码，学不懂技术，不会为人处世，不会有效沟通，一切都是空谈。</li></ul>]]></content>
      
      
      <categories>
          
          <category> deploy problem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
