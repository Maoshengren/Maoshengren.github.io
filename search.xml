<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java NIO</title>
      <link href="/2021/10/24/Java-NIO/"/>
      <url>/2021/10/24/Java-NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><blockquote><p>首先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型: </p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Excutors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPollExecutor</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//线程池</span>    <span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 主线程死循环等待新连接到来</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>currentThread<span class="token punctuation">.</span><span class="token function">isInturrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment">// 接受新的socket</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 为新的连接创建新的线程</span>        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConnectIOnHandler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConnectIOnHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">ConnectIOnHandler</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> socket<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 死循环处理读写事件</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>currentThread<span class="token punctuation">.</span><span class="token function">isInturrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>socket<span class="token punctuation">.</span><span class="token function">isClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 读取数据</span>            <span class="token class-name">String</span> someThing <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>someThing<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment">// 处理数据</span>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                    <span class="token comment">// 写数据</span>                    socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/10/24/Java-NIO/image-20211024112633666.png" alt="" style="zoom:50%;"><blockquote><p>这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于 <code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code>三个主要函数都是同步阻塞的，当一个连接在处理 I/O 的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里。</p><p>这也是为什么在做计网实验的时候单线程只能处理一次请求，如果再次发出请求服务器根本不会响应，因为服务器被阻塞在读写了。</p></blockquote><ul><li>多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单。</li></ul><p>这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：</p><ol><li>线程的创建和销毁成本很高</li><li>线程本身占用较大内存</li><li>线程的切换成本很高</li></ol><hr><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>传统的BIO里面 <code>socket.read()</code>，如果TCP <code>RecvBuffer</code> 里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP <code>RecvBuffer</code>有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。(解释地真地道)</p><blockquote><p>NIO<strong>只有在连接/通道真正有读写事件</strong>发生时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，这就大大地减少了系统的开销。</p></blockquote><table><thead><tr><th align="left">NIO的核心</th><th align="left">对应的类或接口</th><th align="left">应用</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">缓冲区</td><td align="left"><code>Buffer</code></td><td align="left">文件IO/网络IO</td><td align="left">存储数据</td></tr><tr><td align="left">通道</td><td align="left"><code>Channel</code></td><td align="left">文件IO/网络IO</td><td align="left">运输</td></tr><tr><td align="left">选择器</td><td align="left"><code>Selector</code></td><td align="left">网络IO</td><td align="left">控制器</td></tr></tbody></table><h3 id="单线程-Reactor"><a href="#单线程-Reactor" class="headerlink" title="单线程 Reactor"></a><strong>单线程 <code>Reactor</code></strong></h3><blockquote><p><code>Reactor</code> 模型中定义的三种角色：</p></blockquote><ul><li><code>Reactor</code> ：负责监听和分配事件，将I/O事件分派给对应的 <code>Handler</code>。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li><code>Acceptor</code>：处理客户端新连接，并分派请求到处理器链中。</li><li><code>Handler</code>：将自身与事件绑定，执行非阻塞读/写任务，完成 <code>channel</code> 的读入，完成处理业务逻辑后，负责将结果写出 <code>channel</code>。可用资源池来管理。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">ChannelHandler</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">channelReadable</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">channelWritable</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Channel</span><span class="token punctuation">{</span>    <span class="token class-name">Socket</span> socket<span class="token punctuation">;</span>    <span class="token class-name">Event</span> event<span class="token punctuation">;</span><span class="token comment">//读，写或者连接</span><span class="token punctuation">}</span><span class="token comment">//IO线程主循环:</span><span class="token keyword">class</span> <span class="token class-name">IoThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Channel</span> channel<span class="token punctuation">;</span>        <span class="token comment">//选择就绪的事件和对应的连接</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>channel<span class="token operator">=</span><span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>accept<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果是新连接，则注册一个新的读写处理器</span>                <span class="token function">registerNewChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>write<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果可以写，则执行写事件</span>                <span class="token function">getChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channelWritable</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span>event<span class="token operator">==</span>read<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">//如果可以读，则执行读事件</span>                <span class="token function">getChannelHandler</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channelReadable</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//所有channel的对应事件处理器</span>    <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Channel</span>，<span class="token class-name">ChannelHandler</span><span class="token operator">&gt;</span> handlerMap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这也是最简单的 <code>Reactor</code> 模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。 </p><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p></blockquote><img src="/2021/10/24/Java-NIO/image-20211021165753294-16350547783021.png" alt="" style="zoom:40%;"><p><code>Reactor</code> 处理请求的流程：</p><ol><li><code>Reactor</code> 对象通过 <code>select</code> 监控连接事件，收到事件后通过 <code>dispatch</code> 进行转发。</li><li>如果是连接建立的事件，则由 <code>acceptor</code> 接受连接，并创建 <code>handler</code> 处理后续事件。</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用 <code>Handler</code> 来响应。</li><li><code>handler</code> 会完成 <code>read</code> <code>-&gt;</code> 业务处理 <code>-&gt;</code> <code>send</code> 的完整业务流程。</li></ol><blockquote><p><strong>单线程模式的缺点:</strong></p><ol><li>当其中某个 <code>handler</code> 阻塞时， 会导致其他所有的 client 的 <code>handler</code> 都得不到执行， 并且更严重的是， <code>handler</code> 的阻塞也会导致整个服务不能接收新的 client 请求(因为 <code>acceptor</code> 也被阻塞了)。</li></ol></blockquote><h3 id="多线程-Reactor"><a href="#多线程-Reactor" class="headerlink" title="多线程 Reactor"></a><strong>多线程 <code>Reactor</code></strong></h3><blockquote><p>连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。</p><p>在线程 <code>Reactor</code> 模式基础上，做如下改进：</p><p>（1）将 <code>Handler</code> 处理器的执行放入线程池，多线程进行业务处理。 </p><p>（2）而对于 <code>Reactor</code> 而言，可以仍为单个线程。如果服务器为多核的CPU，为充分利用系统资源，可以将 <code>Reactor</code> 拆分为两个线程。</p></blockquote><img src="/2021/10/24/Java-NIO/v2-22efc734724d07251f8293e2f1143639_720w.png" alt="" style="zoom: 67%;"><p>下图是 <code>netty in action</code> 中关于NIO的流程图。</p><p><img src="/2021/10/24/Java-NIO/image-20211022204547930.png"></p><p>多线程 <code>Reactor</code> 消息处理流程：</p><ol><li>从主线程池中随机选择一个 <code>Reactor</code> 线程作为 <code>acceptor</code> 线程，用于绑定监听端口，接收客户端连接</li><li><code>acceptor</code> 线程接收客户端连接请求之后创建新的 <code>SocketChannel</code>，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作</li><li>步骤2完成之后，业务层的链路正式建立，将 <code>SocketChannel</code> 从主线程池的 <code>Reactor</code> 线程的多路复用器上摘除，重新注册到Sub线程池的线程上，并创建一个 <code>Handler</code> 用于处理各种连接事件</li><li>当有新的事件发生时，<code>SubReactor</code> 会调用连接对应的 <code>Handler</code> 进行响应</li><li><code>Handler</code> 通过 <code>Read</code> 读取数据后，会分发给后面的 <code>Worker</code> 线程池进行业务处理</li><li><code>Worker</code> 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 <code>Handler</code> 进行处理</li><li><code> Handler</code> 收到响应结果后通过 <code>Send</code> 将响应结果返回给 <code>Client</code> </li></ol><img src="/2021/10/24/Java-NIO/image-20211024141840397.png" alt="" style="zoom:50%;"><blockquote><p><code>Reactor</code> 模式在 IO 读写数据时还是在同一个线程中实现的，即使使用多个 <code>Reactor</code> 机制的情况下，那些共享一个 <code>Reactor</code> 的 <code>Channel</code> 如果出现一个<strong>长时间的数据读写</strong>，会影响这个 <code>Reactor</code> 中其他<code>Channel</code> 的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的 <code>Thread-Per-Connection</code> 或许是一个更好的选择，或则此时使用改进版的<code>Reactor</code> 模式如 <code>Proactor</code> 模式。</p></blockquote><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a><code>Proactor</code></h3><blockquote><p><code>Reactor</code> 模型用于同步I/O，而 <code>Proactor</code> 模型运用于异步I/O操作。 </p></blockquote><p><strong>模型</strong></p><p><img src="/2021/10/24/Java-NIO/v2-35bd4bdf3b12246fb005415d3a29ecc0_r.jpg"></p><p><strong>模块关系</strong> </p><ol><li><code>Procator Initiator</code>负责创建<code>Procator</code>和<code>Handler</code>，并将<code>Procato</code>r和<code>Handler</code>都通过<code>Asynchronous operation processor</code>注册到内核。</li><li><code>Asynchronous operation processor</code>负责处理注册请求，并完成IO操作。完成IO操作后会通知<code>procator</code>。</li><li><code>procator</code>根据不同的事件类型回调不同的<code>handler</code>进行业务处理。<code>handler</code>完成业务处理，<code>handler</code>也可以注册新的<code>handler</code>到内核进程。</li></ol><p>消息处理流程：</p><p><strong>读取</strong>操作：</p><ol><li>应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。</li><li>事件分离器等待读取操作完成事件。</li><li>在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将数据读写到<strong>应用传递进来的缓冲区</strong>(如Netty中的<code>ByteBuf</code>)中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。</li><li>事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</li></ol><blockquote><p>异步IO都是操作系统负责将数据读写到<strong>应用传递进来的缓冲区</strong>供应用程序操作。</p></blockquote><p>Proactor中写入操作和读取操作，只不过感兴趣的事件是完成事件。</p><blockquote><p>在 Linux 下的异步 I/O 是不完善的， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p></blockquote><hr><h4 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h4><p>Netty采用的是<strong>主从线程模型</strong>。下面是Netty使用中很常见的一段代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">EventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">EventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token annotation punctuation">@Override</span>                 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpServerCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpObjectAggregator</span><span class="token punctuation">(</span><span class="token number">65536</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChunkedWriteHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpStaticFileServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token class-name">Channel</span> ch <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>PORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             ch<span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义了两个<code>EventLoopGroup</code>，其中<code>bossGroup</code>对应的就是主线程池，只接收客户端的连接（注册，初始化逻辑），具体的工作由<code>workerGroup</code>这个从线程池来完成。</li><li>客户端和服务器建立连接后，NIO会在两者之间建立<code>Channel</code>，所以启动类调用<code>channel</code>方法就是为了指定建立什么类型的通道。</li><li>启动类还调用了<code>handler()</code>和<code>childHandler()</code>方法，这两个方法中提及的<code>handler</code>是一个处理类的概念，他负责处理连接后的一个个<code>Channel</code>的相应处理。<code>handler()</code>指定的处理类是主线程池中对通道的处理类，<code>childHandler()</code>方法指定的是从线程池中对通道的处理类。<ul><li>Netty中，可以注册多个<code>handler</code>。<code>ChannelInboundHandler</code>按照注册的先后顺序执行；<code>ChannelOutboundHandler</code>按照注册的先后顺序逆序执行</li></ul></li></ul><blockquote><p>如果需要在客户端连接前的请求进行<code>handler</code>处理，则需要配置<code>handler()</code>；如果是处理客户端连接之后的<code>handler</code>，则需要配置在<code>childHandler()</code>。</p></blockquote><p><strong>Netty三大组件</strong></p><p><code>Channel</code>接口提供了一个API，大大降低了直接使用<code>Sockets</code>的复杂性。当创建<code>Channel</code>时，它会自动分配自己的<code>ChannelPipeline</code>。<code>ChannelPipeline</code>中含有一些<code>ChannelHandlers</code>，用于用户自定义处理事件。数据通过<code>Channel</code>在各个<code>Handler</code>之间流动。</p><p><img src="/2021/10/24/Java-NIO/image-20211024185955001.png"></p><p><code>EventLoop</code>定义了Netty的核心抽象，用于处理在连接生命周期内发生的事件。<code>Channel</code>在其生命周期内注册为一个<code>EventLoop</code>。一个<code>EventLoop</code>可以被分配给一个或多个<code>Channel</code>。</p><p>关系如下图所示：</p><img src="/2021/10/24/Java-NIO/image-20211024185355812.png" alt=""><p>Netty中的所有I/O操作都是<strong>异步</strong>的。因为一个操作可能不会立即返回，所以我们需要一种方法在以后确定它的结果。为此，Netty提供了<code>ChannelFuture</code>，其<code>addListener()</code>方法注册一个<code>ChannelFutureListener</code>，当<strong>操作完成时通知</strong>它(无论是否成功)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">channelFuture<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelProgressiveFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationProgressed</span><span class="token punctuation">(</span><span class="token class-name">ChannelProgressiveFuture</span> future<span class="token punctuation">,</span> <span class="token keyword">long</span> progress<span class="token punctuation">,</span> <span class="token keyword">long</span> total<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// total unknown</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer progress: "</span> <span class="token operator">+</span> progress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer progress: "</span> <span class="token operator">+</span> progress <span class="token operator">+</span> <span class="token string">" / "</span> <span class="token operator">+</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelProgressiveFuture</span> future<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Transfer complete."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码就是通过添加 <code>FutureListener</code> 实现I/O操作完成后在Console中打印信息的功能。</p><hr><p>参考：</p><p>Netty In Action</p><p><a href="https://zhuanlan.zhihu.com/p/23488863">Java NIO浅析 - 知乎 (zhihu.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1573934">netty Reactor模式（源码死磕 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型 - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p><a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署问题</title>
      <link href="/2021/10/23/deploy_problem/"/>
      <url>/2021/10/23/deploy_problem/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo部署到github上遇到的问题"><a href="#Hexo部署到github上遇到的问题" class="headerlink" title="Hexo部署到github上遇到的问题"></a>Hexo部署到github上遇到的问题</h2><ul><li>按照正常流程操作<ul><li>下载node，npm，git等工具</li><li>创建一个合法名字的github仓库</li><li>用 <code>npm install hexo -g</code> 安装hexo</li><li><code>hexo init + npm install</code> 初始化并安装必要组件</li><li><code>hexo g</code> 生成 <code>hexo s</code> 本地预览</li><li><code>hexo d</code> 部署到github上</li></ul></li></ul><p>然后就发现，github上根本不显示我上传的网页。大一那会还什么都不懂，调试了三天都还是错的，最后稀里糊涂地才能访问。<br>其实就是在 <code>_config.yml</code> 文件中：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">deploy:  type: git  repository: git@github.com:Maoshengren/Maoshengren.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不能用 <code>master</code> 分支，需要改成 <code>main</code>。 在github上检查发现文件都已经上传上去了，只是显示的问题，所以肯定是部署错误了，一个是配置中的 <code>url</code> 可能不对</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: http://Maoshengren.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个是我发现我所在的分支名称是 <code>main</code> 而不是<code>master</code>，将这些改好后再次访问我的网站就成功。</p><ul><li>大一刚入学的时候学长让我玩玩 github+hexo 搭建博客系统，那会还什么都不懂，连 github 对我来说也是个新鲜玩意，然后各种搜网上的教程搭建，拆了又搭，搭了发现显示有问题又拆，最后终于把一个蹩脚的网站搭好了，虽然颜值非常丑但至少还是有些成就感的。</li><li>后来因为大一也没啥专业课，唯一需要码代码的课是C语言和实验，所以技术没怎么长进，自然也养不成写博客的习惯。然后人生搭的第一个博客系统就这样荒废了。</li><li>再回首现在已经是大三老人了，这几年终于对计算机建立起了一个比较全面一点的认识，遇到各种问题和各种bug也知道该从哪里找，该怎么调试，挺感慨的。</li><li>从现在开始可以有空发一些文章到网上，一个是加深自己的对知识的理解，一个是可以把自己的学习经历记录下来，等到过几年再回头看，哦，我原来已经走了这么远。</li><li>个人而言未来无论是考研还是工作，努力提高自己的硬实力和软实力，才能在职业上走得长远，一张文凭只是个敲门砖，敲不出代码，学不懂技术，不会为人处世，不会有效沟通，一切都是空谈。</li></ul>]]></content>
      
      
      <categories>
          
          <category> deploy problem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
